[
{"query": "How to generate MD5 hash code", "url": "https://stackoverflow.com/questions/7776116/java-calculate-md5-hash", "url position": 2, "segments": [{"code": "String hashtext = bigInt.toString(16);\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": true, "answer_votes": "3", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "System.out.println(MungPass(\"java\"));\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": true, "answer_votes": "3", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "DigestUtils.md5Hex(str);\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": "38", "answer_stars": 0, "length": false, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://stackoverflow.com/questions/415953/how-can-i-generate-an-md5-hash", "url position": 1, "segments": [{"code": "import java.security.*;\n\n..\n\nbyte[] bytesOfMessage = yourString.getBytes(\"UTF-8\");\n\nMessageDigest md = MessageDigest.getInstance(\"MD5\");\nbyte[] thedigest = md.digest(bytesOfMessage);\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": "621", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "String plaintext = \"your text here\";\nMessageDigest m = MessageDigest.getInstance(\"MD5\");\nm.reset();\nm.update(plaintext.getBytes());\nbyte[] digest = m.digest();\nBigInteger bigInt = new BigInteger(1,digest);\nString hashtext = bigInt.toString(16);\n// Now we need to zero pad it if you actually want the full 32 chars.\nwhile(hashtext.length() < 32 ){\n  hashtext = \"0\"+hashtext;\n}\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": "237", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public String MD5(String md5) {\n   try {\n        java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n        byte[] array = md.digest(md5.getBytes());\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < array.length; ++i) {\n          sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));\n       }\n        return sb.toString();\n    } catch (java.security.NoSuchAlgorithmException e) {\n    }\n    return null;\n}\n", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": "137", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "final MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\nmessageDigest.reset();\nmessageDigest.update(string.getBytes(Charset.forName(\"UTF8\")));\nfinal byte[] resultByte = messageDigest.digest();\nfinal String result = new String(Hex.encodeHex(resultByte));\n", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": "80", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "String Url = \"your_url\";\n\nSystem.out.println( DigestUtils.md5Hex( Url ) );\n", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": "73", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\nmd5.update(StandardCharsets.UTF_8.encode(string));\nreturn String.format(\"%032x\", new BigInteger(1, md5.digest()));\n", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": "48", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "import java.security.*;\nimport java.math.*;\n\npublic class MD5 {\n    public static void main(String args[]) throws Exception{\n        String s=\"This is a test\";\n        MessageDigest m=MessageDigest.getInstance(\"MD5\");\n        m.update(s.getBytes(),0,s.length());\n        System.out.println(\"MD5: \"+new BigInteger(1,m.digest()).toString(16));\n    }\n}\n", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": "31", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "Hasher hasher = Hashing.md5().newHasher();\nhasher.putString(\"my string\");\nbyte[] md5 = hasher.hash().asBytes();\n", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": "29", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "import javax.xml.bind.DatatypeConverter;\n\nString hash = DatatypeConverter.printHexBinary( \n           MessageDigest.getInstance(\"MD5\").digest(\"SOMESTRING\".getBytes(\"UTF-8\")));\n", "in_page_order": 11, "first_in_page": false, "accepted_answer": false, "answer_votes": "27", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public class Hash {\n    /**\n     * \n     * @param txt, text in plain format\n     * @param hashType MD5 OR SHA1\n     * @return hash in hashType \n     */\n    public static String getHash(String txt, String hashType) {\n        try {\n                    java.security.MessageDigest md = java.security.MessageDigest.getInstance(hashType);\n                    byte[] array = md.digest(txt.getBytes());\n                    StringBuffer sb = new StringBuffer();\n                    for (int i = 0; i < array.length; ++i) {\n                        sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));\n                 }\n                    return sb.toString();\n            } catch (java.security.NoSuchAlgorithmException e) {\n                //error action\n            }\n            return null;\n    }\n\n    public static String md5(String txt) {\n        return Hash.getHash(txt, \"MD5\");\n    }\n\n    public static String sha1(String txt) {\n        return Hash.getHash(txt, \"SHA1\");\n    }\n}\n", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": "25", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "<?php\n\necho 'MD5 :' . md5('Hello World') . \"\\n\";\necho 'SHA1:' . sha1('Hello World') . \"\\n\";\n", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": "25", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "MD5 :b10a8db164e0754105b7a99be72e3fe5\nSHA1:0a4d55a8d778e5022fab701977c5d840bbc486d0\n", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": "25", "answer_stars": 0, "length": false, "semicolon": false}, {"code": "    public class HashTest {\n\n    @Test\n    public void test() {\n        String txt = \"Hello World\";\n        assertEquals(\"b10a8db164e0754105b7a99be72e3fe5\", Hash.md5(txt));\n        assertEquals(\"0a4d55a8d778e5022fab701977c5d840bbc486d0\", Hash.sha1(txt));\n    }\n\n}\n", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": "25", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "private String md5(String s) {\n    try {\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(s.getBytes(), 0, s.length());\n        BigInteger i = new BigInteger(1,m.digest());\n        return String.format(\"%1$032x\", i);         \n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "in_page_order": 13, "first_in_page": false, "accepted_answer": false, "answer_votes": "21", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "DigestUtils.md5Hex(_hash);\n", "in_page_order": 14, "first_in_page": false, "accepted_answer": false, "answer_votes": "16", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "DigestUtils.md5(_hash);\n", "in_page_order": 14, "first_in_page": false, "accepted_answer": false, "answer_votes": "16", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class MD5Example {\n\npublic static void main(String[] args) throws Exception {\n\n    final String inputString = \"Hello MD5\";\n\n    System.out.println(\"MD5 hex for '\" + inputString + \"' :\");\n    System.out.println(getMD5Hex(inputString));\n}\n\npublic static String getMD5Hex(final String inputString) throws NoSuchAlgorithmException {\n\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(inputString.getBytes());\n\n    byte[] digest = md.digest();\n\n    return convertByteToHex(digest);\n}\n\nprivate static String convertByteToHex(byte[] byteData) {\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < byteData.length; i++) {\n        sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n    }\n\n    return sb.toString();\n}\n}\n", "in_page_order": 16, "first_in_page": false, "accepted_answer": false, "answer_votes": "13", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "String hash = MD5.asHex(MD5.getHash(new File(filename)));\n", "in_page_order": 18, "first_in_page": false, "accepted_answer": false, "answer_votes": "8", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.net.URL;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.security.DigestOutputStream;        // new\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nvoid downloadFile(String fromURL, String toFile, BigInteger md5)\n    throws IOException, NoSuchAlgorithmException\n{\n    ReadableByteChannel in = Channels.newChannel(new URL(fromURL).openStream());\n    MessageDigest md5Digest = MessageDigest.getInstance(\"MD5\");\n    WritableByteChannel out = Channels.newChannel(\n        //new FileOutputStream(toFile));  // old\n        new DigestOutputStream(new FileOutputStream(toFile), md5Digest));  // new\n    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);  // 1 MB\n\n    while (in.read(buffer) != -1) {\n        buffer.flip();\n        //md5Digest.update(buffer.asReadOnlyBuffer());  // old\n        out.write(buffer);\n        buffer.clear();\n    }\n\n    BigInteger md5Actual = new BigInteger(1, md5Digest.digest()); \n    if (! md5Actual.equals(md5))\n        throw new RuntimeException(\n            \"MD5 mismatch for file \" + toFile +\n            \": expected \" + md5.toString(16) +\n            \", got \" + md5Actual.toString(16)\n        );\n}\n", "in_page_order": 19, "first_in_page": false, "accepted_answer": false, "answer_votes": "7", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "return UUID.nameUUIDFromBytes(md5Bytes).toString();\n", "in_page_order": 22, "first_in_page": false, "accepted_answer": false, "answer_votes": "5", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "public static String getHashMD5(String string) {\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        BigInteger bi = new BigInteger(1, md.digest(string.getBytes()));\n        return bi.toString(16);\n    } catch (NoSuchAlgorithmException ex) {\n        Logger.getLogger(MD5Utils.class\n                .getName()).log(Level.SEVERE, null, ex);\n\n        return \"\";\n    }\n}\n", "in_page_order": 23, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static String md5( String input ) {\n    try {\n        java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n        byte[] array = md.digest(input.getBytes( \"UTF-8\" ));\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < array.length; i++) {\n            sb.append( String.format( \"%02x\", array[i]));\n        }\n        return sb.toString();\n    } catch ( NoSuchAlgorithmException | UnsupportedEncodingException e) {\n        return null;            \n    }\n\n}\n", "in_page_order": 24, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static String md5encryption(String text)\n    {   String hashtext = null;\n        try \n        {\n            String plaintext = text;\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.reset();\n            m.update(plaintext.getBytes());\n            byte[] digest = m.digest();\n            BigInteger bigInt = new BigInteger(1,digest);\n            hashtext = bigInt.toString(16);\n            // Now we need to zero pad it if you actually want the full 32 chars.\n            while(hashtext.length() < 32 ){\n              hashtext = \"0\"+hashtext;   \n            }\n        } catch (Exception e1) \n        {\n            // TODO: handle exception\n            JOptionPane.showMessageDialog(null,e1.getClass().getName() + \": \" + e1.getMessage());   \n        }\n        return hashtext;     \n    }\n", "in_page_order": 25, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "String text = textFieldName.getText();\nString pass = md5encryption(text);\n", "in_page_order": 25, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "import java.security.MessageDigest\n\nval digest = MessageDigest.getInstance(\"MD5\")\n\n//Quick MD5 of text\nval text = \"MD5 this text!\"\nval md5hash1 = digest.digest(text.getBytes).map(\"%02x\".format(_)).mkString\n\n//MD5 of text with updates\ndigest.update(\"MD5 \".getBytes())\ndigest.update(\"this \".getBytes())\ndigest.update(\"text!\".getBytes())\nval md5hash2 = digest.digest().map(0xFF & _).map(\"%02x\".format(_)).mkString\n\n//Output\nprintln(md5hash1 + \" should be the same as \" + md5hash2)\n", "in_page_order": 26, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": true, "semicolon": false}, {"code": "def md5(text: String) : String = java.security.MessageDigest.getInstance(\"MD5\").digest(text.getBytes()).map(0xFF & _).map { \"%02x\".format(_) }.foldLeft(\"\"){_ + _}\n", "in_page_order": 27, "first_in_page": false, "accepted_answer": false, "answer_votes": "2", "answer_stars": 0, "length": true, "semicolon": false}, {"code": " import java.math.BigInteger;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n\n/**\n* MD5 encryption\n*\n* @author Hongten\n*\n*/\npublic class MD5 {\n\n public static void main(String[] args) {\n     System.out.println(MD5.getMD5(\"123456\"));\n }\n\n /**\n  * Use md5 encoded code value\n  *\n  * @param sInput\n  * clearly\n  * @ return md5 encrypted password\n  */\n public static String getMD5(String sInput) {\n\n     String algorithm = \"\";\n     if (sInput == null) {\n         return \"null\";\n     }\n     try {\n         algorithm = System.getProperty(\"MD5.algorithm\", \"MD5\");\n     } catch (SecurityException se) {\n     }\n     MessageDigest md = null;\n     try {\n         md = MessageDigest.getInstance(algorithm);\n     } catch (NoSuchAlgorithmException e) {\n         e.printStackTrace();\n     }\n     byte buffer[] = sInput.getBytes();\n\n     for (int count = 0; count < sInput.length(); count++) {\n         md.update(buffer, 0, count);\n     }\n     byte bDigest[] = md.digest();\n     BigInteger bi = new BigInteger(bDigest);\n     return (bi.toString(16));\n }\n}\n", "in_page_order": 28, "first_in_page": false, "accepted_answer": false, "answer_votes": "0", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "private String hashuj(String dane) throws ServletException{\n    try {\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        byte[] bufor = dane.getBytes();\n        m.update(bufor,0,bufor.length);\n        BigInteger hash = new BigInteger(1,m.dige`enter code here`st());\n        return String.format(\"%1$032X\", hash);\n\n    } catch (NoSuchAlgorithmException nsae) {\n        throw new ServletException(\"Algorytm szyfrowania nie jest obsugiwany!\");\n    }\n}\n", "in_page_order": 29, "first_in_page": false, "accepted_answer": false, "answer_votes": "-2", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public final class MD5 {\npublic enum SaltOption {\n    BEFORE, AFTER, BOTH, NONE;\n}\nprivate static final String ALG = \"MD5\";\n//For conversion to 2-char hex\nprivate static final char[] digits = {\n    '0' , '1' , '2' , '3' , '4' , '5' ,\n    '6' , '7' , '8' , '9' , 'a' , 'b' ,\n    'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,\n    'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,\n    'o' , 'p' , 'q' , 'r' , 's' , 't' ,\n    'u' , 'v' , 'w' , 'x' , 'y' , 'z'\n};\n\nprivate SaltOption opt;\n\n/**\n * Added the SaltOption constructor since everybody\n * has their own standards when it comes to salting\n * hashes.\n * \n * This gives the developer the option...\n * \n * @param option The salt option to use, BEFORE, AFTER, BOTH or NONE.\n */\npublic MD5(final SaltOption option) {\n    //TODO: Add Char Encoding options too... I was too lazy!\n    this.opt = option;\n}\n\n/**\n * \n * Returns the salted MD5 checksum of the text passed in as an argument.\n * \n * If the salt is an empty byte array - no salt is applied.\n * \n * @param txt The text to run through the MD5 algorithm.\n * @param salt The salt value in bytes.\n * @return The salted MD5 checksum as a <code>byte[]</code>\n * @throws NoSuchAlgorithmException\n */\nprivate byte[] createChecksum(final String txt, final byte[] salt) throws NoSuchAlgorithmException {\n    final MessageDigest complete = MessageDigest.getInstance(ALG);\n    if(opt.equals(SaltOption.BEFORE) || opt.equals(SaltOption.BOTH)) {\n        complete.update(salt);\n    }\n    complete.update(txt.getBytes());\n    if(opt.equals(SaltOption.AFTER) || opt.equals(SaltOption.BOTH)) {\n        complete.update(salt);\n    }\n    return complete.digest();\n}\n\n/**\n * \n * Returns the salted MD5 checksum of the file passed in as an argument.\n * \n * If the salt is an empty byte array - no salt is applied.\n * \n * @param fle The file to run through the MD5 algorithm.\n * @param salt The salt value in bytes.\n * @return The salted MD5 checksum as a <code>byte[]</code>\n * @throws IOException\n * @throws NoSuchAlgorithmException\n */\nprivate byte[] createChecksum(final File fle, final byte[] salt)\n        throws IOException, NoSuchAlgorithmException {\n    final byte[] buffer = new byte[1024];\n    final MessageDigest complete = MessageDigest.getInstance(ALG);\n            if(opt.equals(SaltOption.BEFORE) || opt.equals(SaltOption.BOTH)) {\n            complete.update(salt);\n        }\n    int numRead;\n    InputStream fis = null;\n    try {\n        fis = new FileInputStream(fle);\n        do {\n            numRead = fis.read(buffer);\n            if (numRead > 0) {\n                complete.update(buffer, 0, numRead);\n            }\n        } while (numRead != -1);\n    } finally {\n    if (fis != null) {\n            fis.close();\n        }\n    }\n            if(opt.equals(SaltOption.AFTER) || opt.equals(SaltOption.BOTH)) {\n            complete.update(salt);\n        }\n    return complete.digest();\n}\n\n/**\n * \n * Efficiently converts a byte array to its 2 char per byte hex equivalent.\n * \n * This was adapted from JDK code in the Integer class, I just didn't like\n * having to use substrings once I got the result...\n *\n * @param b The byte array to convert\n * @return The converted String, 2 chars per byte...\n */\nprivate String convertToHex(final byte[] b) {\n    int x;\n    int charPos;\n    int radix;\n    int mask;\n    final char[] buf = new char[32];\n    final char[] tmp = new char[3];\n    final StringBuilder md5 = new StringBuilder();\n    for (int i = 0; i < b.length; i++) {\n        x = (b[i] & 0xFF) | 0x100;\n        charPos = 32;\n        radix = 1 << 4;\n        mask = radix - 1;\n        do {\n            buf[--charPos] = digits[x & mask];\n            x >>>= 4;\n        } while (x != 0);\n        System.arraycopy(buf, charPos, tmp, 0, (32 - charPos));\n        md5.append(Arrays.copyOfRange(tmp, 1, 3));\n    }\n    return md5.toString();\n}\n\n/**\n * \n * Returns the salted MD5 checksum of the file passed in as an argument.\n * \n * @param fle The file you want want to run through the MD5 algorithm.\n * @param salt The salt value in bytes\n * @return The salted MD5 checksum as a 2 char per byte HEX <code>String</code>\n * @throws NoSuchAlgorithmException\n * @throws IOException\n */\npublic String getMD5Checksum(final File fle, final byte[] salt)\n        throws NoSuchAlgorithmException, IOException {\n    return convertToHex(createChecksum(fle, salt));\n}\n\n/**\n * \n * Returns the MD5 checksum of the file passed in as an argument.\n * \n * @param fle The file you want want to run through the MD5 algorithm.\n * @return The MD5 checksum as a 2 char per byte HEX <code>String</code>\n * @throws NoSuchAlgorithmException\n * @throws IOException\n */\npublic String getMD5Checksum(final File fle)\n        throws NoSuchAlgorithmException, IOException {\n    return convertToHex(createChecksum(fle, new byte[0]));\n}\n\n/**\n * \n * Returns the salted MD5 checksum of the text passed in as an argument.\n * \n * @param txt The text you want want to run through the MD5 algorithm.\n * @param salt The salt value in bytes.\n * @return The salted MD5 checksum as a 2 char per byte HEX <code>String</code>\n * @throws NoSuchAlgorithmException\n * @throws IOException\n */\npublic String getMD5Checksum(final String txt, final byte[] salt)\n        throws NoSuchAlgorithmException {\n    return convertToHex(createChecksum(txt, salt));\n}\n\n/**\n * \n * Returns the MD5 checksum of the text passed in as an argument.\n * \n * @param txt The text you want want to run through the MD5 algorithm.\n * @return The MD5 checksum as a 2 char per byte HEX <code>String</code>\n * @throws NoSuchAlgorithmException\n * @throws IOException\n */\npublic String getMD5Checksum(final String txt)\n        throws NoSuchAlgorithmException {\n\n    return convertToHex(createChecksum(txt, new byte[0]));\n}\n}\n", "in_page_order": 30, "first_in_page": false, "accepted_answer": false, "answer_votes": "-3", "answer_stars": 0, "length": false, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "http://www.baeldung.com/java-md5", "url position": 6, "segments": [{"code": "MessageDigest.getInstance(String Algorithm)", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public void update(byte [] input)", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public byte[] digest()", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "@Test\r\npublic void givenPassword_whenHashing_thenVerifying() \r\n  throws NoSuchAlgorithmException {\r\n    String hash = \"35454B055CC325EA1AF2126E27707052\";\r\n    String password = \"ILoveJava\";\r\n        \r\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n    md.update(password.getBytes());\r\n    byte[] digest = md.digest();\r\n    String myHash = DatatypeConverter\r\n      .printHexBinary(digest).toUpperCase();\r\n        \r\n    assertThat(myHash.equals(hash)).isTrue();\r\n}", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "@Test\r\npublic void givenFile_generatingChecksum_thenVerifying() \r\n  throws NoSuchAlgorithmException, IOException {\r\n    String filename = \"src/test/resources/test_md5.txt\";\r\n    String checksum = \"5EB63BBBE01EEED093CB22BB8F5ACDC3\";\r\n        \r\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n    md.update(Files.readAllBytes(Paths.get(filename)));\r\n    byte[] digest = md.digest();\r\n    String myChecksum = DatatypeConverter\r\n      .printHexBinary(digest).toUpperCase();\r\n        \r\n    assertThat(myChecksum.equals(checksum)).isTrue();\r\n}", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "@Test\r\npublic void givenPassword_whenHashingUsingCommons_thenVerifying()  {\r\n    String hash = \"35454B055CC325EA1AF2126E27707052\";\r\n    String password = \"ILoveJava\";\r\n\r\n    String md5Hex = DigestUtils\r\n      .md5Hex(password).toUpperCase();\r\n        \r\n    assertThat(md5Hex.equals(hash)).isTrue();\r\n}", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "@Test\r\npublic void givenFile_whenChecksumUsingGuava_thenVerifying() \r\n  throws IOException {\r\n    String filename = \"src/test/resources/test_md5.txt\";\r\n    String checksum = \"5EB63BBBE01EEED093CB22BB8F5ACDC3\";\r\n        \r\n    HashCode hash = com.google.common.io.Files\r\n      .hash(new File(filename), Hashing.md5());\r\n    String myChecksum = hash.toString()\r\n      .toUpperCase();\r\n        \r\n    assertThat(myChecksum.equals(checksum)).isTrue();\r\n}", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://stackoverflow.com/questions/4883145/how-to-generate-hash-of-any-file-in-java", "url position": 3, "segments": [{"code": "String myHash = \"MD5\"; // or \"SHA-1\" or \"SHA-256\"\nMessageDigest complete = MessageDigest.getInstance(myHash);\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": true, "answer_votes": "6", "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://codereview.stackexchange.com/questions/153182/java-class-to-compute-and-get-a-md5-hash-as-a-string", "url position": 10, "segments": [{"code": "package Md5Generator;\n\n/**\n *\n * @author jacob\n */\n import java.io.IOException;\n import java.security.*;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n import java.nio.file.Path;\n\n /**\n  * The point of this class it to compute the MD5 sum of a file\n  */\n public class Md5 {\n// two instance variables, one to store the file path and one to store the MD5 sum\nprivate String path;\nprivate String md5Sum;\n\n/**\n * Constructor that takes a file path and and calcs the MD5 sum\n *\n * @param filePath the string that contains the full path to the file\n */\npublic Md5(String filePath) {\n    path = filePath;\n    calcMd5(path);\n}\n\nprivate void calcMd5(String filePath) {\n    //create a messagedigest object to compute an MD5 sum\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        //create a input stream to get the bytes of the file\n        Path path = Paths.get(filePath);\n        //read the bytes from the file and put them in the message digest\n        md.update(Files.readAllBytes(path));\n        //digest the bytes and generate an MD5 sum thats stored in an array of bytes\n        byte[] hash = md.digest();\n        //convert the byte array to its hex counter parts and store it as a string\n        md5Sum = toHexString(hash);\n    } catch (IOException | NoSuchAlgorithmException ex) {\n        ex.printStackTrace();\n    }\n\n}\n\nprivate String toHexString(byte[] bytes) {\n    char[] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    char[] hexChars = new char[bytes.length * 2];\n    int v;\n    for (int j = 0; j < bytes.length; j++) {\n        v = bytes[j] & 0xFF;\n        hexChars[j * 2] = hexArray[v / 16];\n        hexChars[j * 2 + 1] = hexArray[v % 16];\n    }\n    return new String(hexChars);\n}\n\n/**\n * Returns the MD5 sum as a String\n *\n * @return the string that contains the MD5 sum\n */\npublic String getMd5Sum() {\n    return md5Sum;\n}\n}\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "md.update(Files.readAllBytes(path));\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "try (MessageDigest md = MessageDigest.getInstance(\"MD5\")) {\n    try (FileChannel fc = FileChannel.open(Paths.get(filePath))) {\n        long meg = 1024 * 1024;\n        long len = fc.size();\n        long pos = 0;\n        while (pos < len) {\n            long size = Math.min(meg, len - pos);\n            MappedByteBuffer mbb = fc.map(MapMode.READ_ONLY, pos, size);\n            md.update(mbb);\n            pos += size;\n        }\n    } catch (IOException ioe) {\n        ....\n    }\n    byte[] hash = md.digest();\n    .....\n} catch ( NoSuchAlgorithmException nsae) {\n    ....\n}\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "//digest the bytes and generate an MD5 sum thats stored in an array of bytes\nbyte[] hash = md.digest();\n//convert the byte array to its hex counter parts and store it as a string\nmd5Sum = toHexString(hash);\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "// digest the bytes, generate an MD5 hash and store it as a hex string\nmd5sum = String.format(\"%032x\", new BigInteger(1, md.digest()));\n", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "// two instance variables, one to store the file path and one to store the MD5 sum\nprivate String path;\nprivate String md5Sum;\n", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "// Cache for the computed sum\nprivate String md5Sum;\n", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "// Mask on int conversion to prevent sign extension\nv = bytes[j] & 0xFF;`\n", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "public class DigestUtils {\n    public static md5Hex(Path path) { ... }\n}\n", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "http://www.anyexample.com/programming/java/java_simple_class_to_compute_md5_hash.xml", "url position": 11, "segments": [{"code": "\r\nimport java.io.UnsupportedEncodingException; \r\nimport java.security.MessageDigest; \r\nimport java.security.NoSuchAlgorithmException; \r\n\r\npublic class AeSimpleMD5 { \r\n\r\n    private static String convertToHex(byte[] data) { \r\n        StringBuffer buf = new StringBuffer();\r\n        for (int i = 0; i < data.length; i++) { \r\n            int halfbyte = (data[i] >>> 4) & 0x0F;\r\n            int two_halfs = 0;\r\n            do { \r\n                if ((0 <= halfbyte) && (halfbyte <= 9)) \r\n                    buf.append((char) ('0' + halfbyte));\r\n                else \r\n                    buf.append((char) ('a' + (halfbyte - 10)));\r\n                halfbyte = data[i] & 0x0F;\r\n            } while(two_halfs++ < 1);\r\n        } \r\n        return buf.toString();\r\n    } \r\n\r\n    public static String MD5(String text) \r\n    throws NoSuchAlgorithmException, UnsupportedEncodingException  { \r\n        MessageDigest md;\r\n        md = MessageDigest.getInstance(\"MD5\");\r\n        byte[] md5hash = new byte[32];\r\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\r\n        md5hash = md.digest();\r\n        return convertToHex(md5hash);\r\n    } \r\n} \r\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\r\nString MD5_ad1 = AeSimpleMD5.MD5(\"Java solutions class libraries\");\r\nString MD5_ad2 = AeSimpleMD5.MD5(\"Java Toolkits\");\r\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\r\nimport java.io.BufferedReader; \r\nimport java.io.IOException; \r\nimport java.io.InputStreamReader; \r\nimport java.io.UnsupportedEncodingException; \r\nimport java.security.NoSuchAlgorithmException; \r\n\r\npublic class Ex01 { \r\n\r\n    public static void main(String[] args) throws IOException { \r\n        BufferedReader userInput = new BufferedReader (new InputStreamReader(System.in));\r\n\r\n        System.out.println(\"Enter string:\");\r\n        String rawString = userInput.readLine();\r\n\r\n        try { \r\n            System.out.println(\"MD5 hash of string: \" + AeSimpleMD5.MD5(rawString));\r\n        } catch (NoSuchAlgorithmException e) { \r\n            // TODO Auto-generated catch block \r\n            e.printStackTrace();\r\n        } catch (UnsupportedEncodingException e) { \r\n            // TODO Auto-generated catch block \r\n            e.printStackTrace();\r\n        } \r\n    } \r\n} \r\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://stackoverflow.com/questions/2920044/how-can-you-generate-the-same-md5-hashcode-in-c-sharp-and-java", "url position": 4, "segments": [{"code": "byte[] digest = m.digest(bytes);\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": true, "answer_votes": "22", "answer_stars": 0, "length": false, "semicolon": true}, {"code": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nclass Test\n{\n    static void Main()\n    {\n        byte[] bytes = { 0x35, 0x24, 0x76, 0x12 };\n        MD5 md5 = new MD5CryptoServiceProvider();\n        byte[] result = md5.ComputeHash(bytes);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < result.Length; i++)\n        {\n            sb.Append(result[i].ToString(\"x2\"));\n        }\n        Console.WriteLine(sb);\n    }\n}\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": true, "answer_votes": "22", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "import java.math.BigInteger;\nimport java.security.MessageDigest;\n\npublic class Test\n{\n    public static void main(String[] args) throws Exception\n    {\n        byte[] bytes = { 0x35, 0x24, 0x76, 0x12 };\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        byte[] digest = m.digest(bytes);\n        String hash = new BigInteger(1, digest).toString(16);\n        System.out.println(hash);\n    }\n}\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": true, "answer_votes": "22", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "    public static string ConvertStringToMD5(string ClearText)\n{\n\n    byte[] ByteData = Encoding.ASCII.GetBytes(ClearText);\n    //MD5 creating MD5 object.\n    MD5 oMd5 = MD5.Create();\n    //Hash deerini hesaplayalm.\n    byte[] HashData = oMd5.ComputeHash(ByteData);\n\n    //convert byte array to hex format\n    StringBuilder oSb = new StringBuilder();\n\n    for (int x = 0; x < HashData.Length; x++)\n    {\n        //hexadecimal string value\n        oSb.Append(HashData[x].ToString(\"x2\"));\n    }\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "    private String getMD5Digest(byte[] buffer) {\n    String resultHash = null;\n    try {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n        byte[] result = new byte[md5.getDigestLength()];\n        md5.reset();\n        md5.update(buffer);\n        result = md5.digest();\n\n        StringBuffer buf = new StringBuffer(result.length * 2);\n\n        for (int i = 0; i < result.length; i++) {\n            int intVal = result[i] & 0xff;\n            if (intVal < 0x10) {\n                buf.append(\"0\");\n            }\n            buf.append(Integer.toHexString(intVal));\n        }\n\n        resultHash = buf.toString();\n    } catch (NoSuchAlgorithmException e) {\n    }\n    return resultHash;\n}\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": "3", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static string getMD5(string fullPath)\n{\n    MD5 md5 = MD5.Create();\n    using (FileStream stream = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n    {\n        byte[] hash = md5.ComputeHash(stream);\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < hash.Length; j++)\n        {\n            sb.Append(hash[j].ToString(\"X2\"));\n        }\n        return sb.ToString();\n    }\n}\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": "1", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static String checkSumApacheCommons(String filePath)\n{\n    String checksum = null;\n    try \n    {  \n         checksum = DigestUtils.md5Hex(new FileInputStream(filePath));\n    }\n    catch (IOException ex) \n    {\n        ex.printStackTrace(System.out);\n    }\n    return checksum.toUpperCase();\n}\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": "1", "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://www.avajava.com/tutorials/lessons/how-do-i-generate-an-md5-digest-for-a-string.html", "url position": 8, "segments": [{"code": "package digest;\r\n\r\nimport java.security.MessageDigest;\r\n\r\npublic class MD5Digest {\r\n\r\n\tpublic static void main(String[] args) throws Exception {\r\n\r\n\t\tif (args.length != 1) {\r\n\t\t\tSystem.err.println(\"String to MD5 digest should be first and only parameter\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tString original = args[0];\r\n\t\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n\t\tmd.update(original.getBytes());\r\n\t\tbyte[] digest = md.digest();\r\n\t\tStringBuffer sb = new StringBuffer();\r\n\t\tfor (byte b : digest) {\r\n\t\t\tsb.append(String.format(\"%02x\", b & 0xff));\r\n\t\t}\r\n\r\n\t\tSystem.out.println(\"original:\" + original);\r\n\t\tSystem.out.println(\"digested(hex):\" + sb.toString());\r\n\t}\r\n\r\n}\r\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\noriginal:secret\r\ndigested(hex):5ebe2294ecd0e0f08eab7690d2a6ee69\r\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://stackoverflow.com/questions/2644847/how-to-generate-a-checksum-for-an-java-object", "url position": 5, "segments": [{"code": "\nprivate BigInteger checksum(Object obj) throws IOException, NoSuchAlgorithmException {\n\n    if (obj == null) {\n      return BigInteger.ZERO;   \n    }\n\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(obj);\n    oos.close();\n\n    MessageDigest m = MessageDigest.getInstance(\"SHA1\");\n    m.update(baos.toByteArray());\n\n    return new BigInteger(1, m.digest());\n}\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": "8", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static String getChecksum(Serializable object) throws IOException, NoSuchAlgorithmException {\n    ByteArrayOutputStream baos = null;\n    ObjectOutputStream oos = null;\n    try {\n        baos = new ByteArrayOutputStream();\n        oos = new ObjectOutputStream(baos);\n        oos.writeObject(object);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] thedigest = md.digest(baos.toByteArray());\n        return DatatypeConverter.printHexBinary(thedigest);\n    } finally {\n        oos.close();\n        baos.close();\n    }\n}\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": "6", "answer_stars": 0, "length": true, "semicolon": true}, {"code": "   public int checksum() {\n     // you pick a hard-coded, randomly chosen, non-zero, odd number\n     // ideally different for each class\n     return new HashCodeBuilder(17, 37).\n       append(property1).\n       append(property2).\n       append(property3).\n       toHashCode();\n   }\n", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": "2", "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "http://www.asjava.com/core-java/java-md5-example/", "url position": 12, "segments": [{"code": "import java.io.FileInputStream;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.math.BigInteger;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\npublic class MD5 {\r\n    public static String getMD5(String input) {\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n            byte[] messageDigest = md.digest(input.getBytes());\r\n            BigInteger number = new BigInteger(1, messageDigest);\r\n            String hashtext = number.toString(16);\r\n            // Now we need to zero pad it if you actually want the full 32 chars.\r\n            while (hashtext.length() < 32) {\r\n                hashtext = \"0\" + hashtext;\r\n            }\r\n            return hashtext;\r\n        }\r\n        catch (NoSuchAlgorithmException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws NoSuchAlgorithmException {\r\n        System.out.println(getMD5(\"Javarmi.com\"));\r\n    }\r\n}", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "import java.io.FileInputStream;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.math.BigInteger;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\npublic class MD5 {\r\n    public static String getMD5(String input) {\r\n        byte[] source;\r\n        try {\r\n            //Get byte according by specified coding.\r\n            source = input.getBytes(\"UTF-8\");\r\n        } catch (UnsupportedEncodingException e) {\r\n            source = input.getBytes();\r\n        }\r\n        String result = null;\r\n        char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7',\r\n                '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n            md.update(source);\r\n            //The result should be one 128 integer\r\n            byte temp[] = md.digest();\r\n            char str[] = new char[16 * 2];\r\n            int k = 0;\r\n            for (int i = 0; i < 16; i++) {\r\n                byte byte0 = temp[i];\r\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\r\n                str[k++] = hexDigits[byte0 & 0xf];\r\n            }\r\n            result = new String(str);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public static void main(String[] args) throws NoSuchAlgorithmException {\r\n        System.out.println(getMD5(\"Javarmi.com\"));\r\n    }\r\n}", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "    public static void main(String[] args) throws Exception {\r\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n        FileInputStream fis = new FileInputStream(\"c:\\\\apache\\\\cxf.jar\");\r\n\r\n        byte[] dataBytes = new byte[1024];\r\n\r\n        int nread = 0;\r\n        while ((nread = fis.read(dataBytes)) != -1) {\r\n            md.update(dataBytes, 0, nread);\r\n        };\r\n        byte[] mdbytes = md.digest();\r\n        StringBuffer sb = new StringBuffer();\r\n        for (int i = 0; i < mdbytes.length; i++) {\r\n            sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));\r\n        }\r\n        System.out.println(\"Digest(in hex format):: \" + sb.toString());\r\n    }", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://www.mkyong.com/java/java-md5-hashing-example/", "url position": 7, "segments": [{"code": "\r\npackage com.mkyong.test;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.security.MessageDigest;\r\n\r\npublic class MD5CheckSumExample \r\n{\r\n    public static void main(String[] args)throws Exception\r\n    {\r\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n        FileInputStream fis = new FileInputStream(\"c:\\\\loging.log\");\r\n        \r\n        byte[] dataBytes = new byte[1024];\r\n     \r\n        int nread = 0; \r\n        while ((nread = fis.read(dataBytes)) != -1) {\r\n          md.update(dataBytes, 0, nread);\r\n        };\r\n        byte[] mdbytes = md.digest();\r\n     \r\n        //convert the byte to hex format method 1\r\n        StringBuffer sb = new StringBuffer();\r\n        for (int i = 0; i < mdbytes.length; i++) {\r\n          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));\r\n        }\r\n\r\n        System.out.println(\"Digest(in hex format):: \" + sb.toString());\r\n        \r\n        //convert the byte to hex format method 2\r\n        StringBuffer hexString = new StringBuffer();\r\n    \tfor (int i=0;i<mdbytes.length;i++) {\r\n    \t\tString hex=Integer.toHexString(0xff & mdbytes[i]);\r\n   \t     \tif(hex.length()==1) hexString.append('0');\r\n   \t     \thexString.append(hex);\r\n    \t}\r\n    \tSystem.out.println(\"Digest(in hex format):: \" + hexString.toString());\r\n    }\r\n}\r\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\r\nDigest(in hex format):: e72c504dc16c8fcd2fe8c74bb492affa\r\nDigest(in hex format):: e72c504dc16c8fcd2fe8c74bb492affa\r\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "\r\npackage com.mkyong.test;\r\n\r\nimport java.security.MessageDigest;\r\n\r\npublic class MD5HashingExample \r\n{\r\n    public static void main(String[] args)throws Exception\r\n    {\r\n    \tString password = \"123456\";\r\n    \t\r\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n        md.update(password.getBytes());\r\n        \r\n        byte byteData[] = md.digest();\r\n \r\n        //convert the byte to hex format method 1\r\n        StringBuffer sb = new StringBuffer();\r\n        for (int i = 0; i < byteData.length; i++) {\r\n         sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\r\n        }\r\n     \r\n        System.out.println(\"Digest(in hex format):: \" + sb.toString());\r\n        \r\n        //convert the byte to hex format method 2\r\n        StringBuffer hexString = new StringBuffer();\r\n    \tfor (int i=0;i<byteData.length;i++) {\r\n    \t\tString hex=Integer.toHexString(0xff & byteData[i]);\r\n   \t     \tif(hex.length()==1) hexString.append('0');\r\n   \t     \thexString.append(hex);\r\n    \t}\r\n    \tSystem.out.println(\"Digest(in hex format):: \" + hexString.toString());\r\n    }\r\n}\r\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\r\nDigest(in hex format):: e10adc3949ba59abbe56e057f20f883e\r\nDigest(in hex format):: e10adc3949ba59abbe56e057f20f883e\r\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://dzone.com/articles/get-md5-hash-few-lines-java", "url position": 9, "segments": [{"code": "\nimport java.security.*;\nimport java.math.*;\n\npublic class MD5 {\n   public static void main(String args[]) throws Exception{\n      String s=\"This is a test\";\n      MessageDigest m=MessageDigest.getInstance(\"MD5\");\n      m.update(s.getBytes(),0,s.length());\n      System.out.println(\"MD5: \"+new BigInteger(1,m.digest()).toString(16));\n   }\n}", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://hadoop.apache.org/docs/r2.7.4/api/org/apache/hadoop/io/MD5Hash.html", "url position": 19, "segments": [{"code": "@InterfaceAudience.Public\n @InterfaceStability.Stable\npublic class MD5Hash\nextends Object\nimplements WritableComparable<MD5Hash>", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public static finalint MD5_LEN", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicMD5Hash()", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicMD5Hash(Stringhex)", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicMD5Hash(byte[]digest)", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidreadFields(DataInputin)\n                throws IOException", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMD5Hashread(DataInputin)\n                    throws IOException", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidwrite(DataOutputout)\n           throws IOException", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidset(MD5Hashthat)", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicbyte[]getDigest()", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMD5Hashdigest(byte[]data)", "in_page_order": 11, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMessageDigestgetDigester()", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMD5Hashdigest(InputStreamin)\n                      throws IOException", "in_page_order": 13, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMD5Hashdigest(byte[]data,\n                             intstart,\n                             intlen)", "in_page_order": 14, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public staticMD5Hashdigest(Stringstring)", "in_page_order": 15, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMD5Hashdigest(org.apache.hadoop.io.UTF8utf8)", "in_page_order": 16, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publiclonghalfDigest()", "in_page_order": 17, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicintquarterDigest()", "in_page_order": 18, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicbooleanequals(Objecto)", "in_page_order": 19, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicinthashCode()", "in_page_order": 20, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicintcompareTo(MD5Hashthat)", "in_page_order": 21, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicStringtoString()", "in_page_order": 22, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidsetDigest(Stringhex)", "in_page_order": 23, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "http://www.codexpedia.com/java/java-md5-hash-example-one-way-hash/", "url position": 18, "segments": [{"code": "\r\nimport java.math.BigInteger;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\npublic class MD5Hash {\r\n \r\n\tprivate final static String salt=\"DGE$5SGr@3VsHYUMas2323E4d57vfBfFSTRU@!DSH(*%FDSdfg13sgfsg\";\r\n\t\r\n    public static void main(String[] args) {\r\n            String password = \"thisismypassword\";\r\n            String empty =  null;\r\n            String msg = \"This is a text message.\";\r\n            System.out.println(password+\" MD5 hashed to>>>>>>> \" + md5Hash(password));\r\n            System.out.println(empty+\" MD5 hashed to>>>>>>> \" + md5Hash(null));\r\n            System.out.println(msg+\" MD5 hashed to>>>>>>> \" + md5Hash(msg));\r\n    }\r\n\r\n    //Takes a string, and converts it to md5 hashed string.\r\n    public static String md5Hash(String message) {\r\n        String md5 = \"\";\r\n        if(null == message) \r\n        \treturn null;\r\n        \r\n        message = message+salt;//adding a salt to the string before it gets hashed.\r\n        try {\r\n\t        MessageDigest digest = MessageDigest.getInstance(\"MD5\");//Create MessageDigest object for MD5\r\n\t        digest.update(message.getBytes(), 0, message.length());//Update input string in message digest\r\n\t        md5 = new BigInteger(1, digest.digest()).toString(16);//Converts message digest value in base 16 (hex)\r\n \r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return md5;\r\n    }\r\n}\r\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "http://www.codejava.net/coding/how-to-calculate-md5-and-sha-hash-values-in-java", "url position": 13, "segments": [{"code": "// algorithm can be \"MD5\", \"SHA-1\", \"SHA-256\"\nMessageDigest digest = MessageDigest.getInstance(algorithm);\n\nbyte[] inputBytes = // get bytes array from message\n\nbyte[] hashBytes = digest.digest(inputBytes);\n\n// convert hash bytes to string (usually in hexadecimal form)", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "MessageDigest digest = MessageDigest.getInstance(algorithm);\n\nbyte[] inputBytes = // get bytes array from message\n\ndigest.update(inputBytes);\n\nbyte[] hashedBytes = digest.digest();\n\n// convert hash bytes to string (usually in hexadecimal form)", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "private static String hashString(String message, String algorithm)\n\t\tthrows HashGenerationException {\n\n\ttry {\n\t\tMessageDigest digest = MessageDigest.getInstance(algorithm);\n\t\tbyte[] hashedBytes = digest.digest(message.getBytes(\"UTF-8\"));\n\n\t\treturn convertByteArrayToHexString(hashedBytes);\n\t} catch (NoSuchAlgorithmException | UnsupportedEncodingException ex) {\n\t\tthrow new HashGenerationException(\n\t\t\t\t\"Could not generate hash from String\", ex);\n\t}\n}", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "private static String convertByteArrayToHexString(byte[] arrayBytes) {\n\tStringBuffer stringBuffer = new StringBuffer();\n\tfor (int i = 0; i < arrayBytes.length; i++) {\n\t\tstringBuffer.append(Integer.toString((arrayBytes[i] & 0xff) + 0x100, 16)\n\t\t\t\t.substring(1));\n\t}\n\treturn stringBuffer.toString();\n}", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static String generateMD5(String message) throws HashGenerationException {\n\treturn hashString(message, \"MD5\");\n}\n\npublic static String generateSHA1(String message) throws HashGenerationException {\n\treturn hashString(message, \"SHA-1\");\n}\n\npublic static String generateSHA256(String message) throws HashGenerationException {\n\treturn hashString(message, \"SHA-256\");\n}", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "package net.codejava.security;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * Hash functions utility class.\n * @author www.codejava.net\n *\n */\npublic class HashGeneratorUtils {\n\tprivate HashGeneratorUtils() {\n\n\t}\n\n\tpublic static String generateMD5(String message) throws HashGenerationException {\n\t\treturn hashString(message, \"MD5\");\n\t}\n\n\tpublic static String generateSHA1(String message) throws HashGenerationException {\n\t\treturn hashString(message, \"SHA-1\");\n\t}\n\n\tpublic static String generateSHA256(String message) throws HashGenerationException {\n\t\treturn hashString(message, \"SHA-256\");\n\t}\n\n\tprivate static String hashString(String message, String algorithm)\n\t\t\tthrows HashGenerationException {\n\n\t\ttry {\n\t\t\tMessageDigest digest = MessageDigest.getInstance(algorithm);\n\t\t\tbyte[] hashedBytes = digest.digest(message.getBytes(\"UTF-8\"));\n\n\t\t\treturn convertByteArrayToHexString(hashedBytes);\n\t\t} catch (NoSuchAlgorithmException | UnsupportedEncodingException ex) {\n\t\t\tthrow new HashGenerationException(\n\t\t\t\t\t\"Could not generate hash from String\", ex);\n\t\t}\n\t}\n\n\tprivate static String convertByteArrayToHexString(byte[] arrayBytes) {\n\t\tStringBuffer stringBuffer = new StringBuffer();\n\t\tfor (int i = 0; i < arrayBytes.length; i++) {\n\t\t\tstringBuffer.append(Integer.toString((arrayBytes[i] & 0xff) + 0x100, 16)\n\t\t\t\t\t.substring(1));\n\t\t}\n\t\treturn stringBuffer.toString();\n\t}\n}", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "package net.codejava.security;\n\n/**\n * Test generating hash values from String.\n * @author www.codejava.net\n *\n */\npublic class StringHashGeneratorExample {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString inputString = args[0];\n\t\t\tSystem.out.println(\"Input String: \" + inputString);\n\n\t\t\tString md5Hash = HashGeneratorUtils.generateMD5(inputString);\n\t\t\tSystem.out.println(\"MD5 Hash: \" + md5Hash);\n\n\t\t\tString sha1Hash = HashGeneratorUtils.generateSHA1(inputString);\n\t\t\tSystem.out.println(\"SHA-1 Hash: \" + sha1Hash);\n\n\t\t\tString sha256Hash = HashGeneratorUtils.generateSHA256(inputString);\n\t\t\tSystem.out.println(\"SHA-256 Hash: \" + sha256Hash);\n\t\t} catch (HashGenerationException ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n\n}", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "Input String: admin\nMD5 Hash: 21232f297a57a5a743894a0e4a801fc3\nSHA-1 Hash: d033e22ae348aeb5660fc2140aec35850c4da997\nSHA-256 Hash: 8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "private static String hashFile(File file, String algorithm)\n\t\tthrows HashGenerationException {\n\ttry (FileInputStream inputStream = new FileInputStream(file)) {\n\t\tMessageDigest digest = MessageDigest.getInstance(algorithm);\n\n\t\tbyte[] bytesBuffer = new byte[1024];\n\t\tint bytesRead = -1;\n\n\t\twhile ((bytesRead = inputStream.read(bytesBuffer)) != -1) {\n\t\t\tdigest.update(bytesBuffer, 0, bytesRead);\n\t\t}\n\n\t\tbyte[] hashedBytes = digest.digest();\n\n\t\treturn convertByteArrayToHexString(hashedBytes);\n\t} catch (NoSuchAlgorithmException | IOException ex) {\n\t\tthrow new HashGenerationException(\n\t\t\t\t\"Could not generate hash from file\", ex);\n\t}\n}", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "public static String generateMD5(File file) throws HashGenerationException {\n\treturn hashFile(file, \"MD5\");\n}\n\npublic static String generateSHA1(File file) throws HashGenerationException {\n\treturn hashFile(file, \"SHA-1\");\n}\n\npublic static String generateSHA256(File file) throws HashGenerationException {\n\treturn hashFile(file, \"SHA-256\");\n}", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "package net.codejava.security;\n\nimport java.io.File;\n\n/**\n * Test generating hash values from File.\n * @author www.codejava.net\n *\n */\npublic class FileHashGeneratorExample {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString filePath = args[0];\n\t\t\tSystem.out.println(\"File Path: \" + filePath);\n\t\t\tFile file = new File(filePath);\n\t\t\t\n\t\t\tString md5Hash = HashGeneratorUtils.generateMD5(file);\n\t\t\tSystem.out.println(\"MD5 Hash: \" + md5Hash);\n\t\t\t\n\t\t\tString sha1Hash = HashGeneratorUtils.generateSHA1(file);\n\t\t\tSystem.out.println(\"SHA-1 Hash: \" + sha1Hash);\n\n\t\t\tString sha256Hash = HashGeneratorUtils.generateSHA256(file);\n\t\t\tSystem.out.println(\"SHA-256 Hash: \" + sha256Hash);\t\t\t\n\n\t\t} catch (HashGenerationException ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n\n}", "in_page_order": 11, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "File Path: D:\\Java\\PDFViewer\\JPedalPDFViewer.zip\nMD5 Hash: 56a86f56a18b73353e5f0afa7b142ed1\nSHA-1 Hash: dc55bd7e84c4787242499ec068fa145bcca01937\nSHA-256 Hash: 093059d79d009662a0a7f70c74cec934a73c1becc8ac813cdcc4995f2aeb882c", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "http://www.java2s.com/Code/Java/Development-Class/MD5hashgenerator.htm", "url position": 15, "segments": [{"code": "       \n/*\n * written Santeri Paavolainen, Helsinki Finland 1996\n * (c) Santeri Paavolainen, Helsinki Finland 1996\n * modifications Copyright (C) 2002-2007 Stephen Ostermiller\n * http://ostermiller.org/contact.pl?regarding=Java+Utilities\n * Copyright (C) 2007 Stu Thompson stu.comp -at- mailworks.org\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * See COPYING.TXT for details.\n *\n * The original work by Santeri Paavolainen can be found at\n * http://www.helsinki.fi/~sjpaavol/programs/md5/\n *\n * This Java class has been derived from the RSA Data Security, Inc. MD5\n * Message-Digest Algorithm and its reference implementation.\n */\n\nimport java.io.*;\n\n/**\n * MD5 hash generator.\n * More information about this class is available from <a target=\"_top\" href=\n * \"http://ostermiller.org/utils/MD5.html\">ostermiller.org</a>.\n * <p>\n * This class takes as input a message of arbitrary length and produces\n * as output a 128-bit \"fingerprint\" or \"message digest\" of the input.\n * It is conjectured that it is computationally infeasible to produce\n * two messages having the same message digest, or to produce any\n * message having a given pre-specified target message digest. The MD5\n * algorithm is intended for digital signature applications, where a\n * large file must be \"compressed\" in a secure manner before being\n * encrypted with a private (secret) key under a public-key cryptosystem\n * such as RSA.\n * <p>\n * For more information see RFC1321.\n *\n * @see MD5OutputStream\n * @see MD5InputStream\n *\n * @author Santeri Paavolainen http://www.helsinki.fi/~sjpaavol/programs/md5/\n * @author Stephen Ostermiller http://ostermiller.org/contact.pl?regarding=Java+Utilities\n * @since ostermillerutils 1.00.00\n */\npublic class MD5 {\n\n  /**\n   * Class constructor\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public MD5 () {\n    reset();\n  }\n\n  /**\n   * Command line program that will take files as arguments\n   * and output the MD5 sum for each file.\n   *\n   * @param args command line arguments\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static void main (String[] args){\n    if (args.length == 0){\n      System.err.println(\"Please specify a file.\");\n    } else {\n      for (String element: args) {\n        try {\n          System.out.println(MD5.getHashString(new File(element)) + \" \" + element);\n        } catch (IOException x){\n          System.err.println(x.getMessage());\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets this hash sum as an array of 16 bytes.\n   *\n   * @return Array of 16 bytes, the hash of all updated bytes.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public byte[] getHash() {\n    if (!finalState.valid) {\n      finalState.copy(workingState);\n      long bitCount = finalState.bitCount;\n      // Compute the number of left over bits\n      int leftOver = (int) (((bitCount >>> 3)) & 0x3f);\n      // Compute the amount of padding to add based on number of left over bits.\n      int padlen = (leftOver < 56) ? (56 - leftOver) : (120 - leftOver);\n      // add the padding\n      update(finalState, padding, 0, padlen);\n      // add the length (computed before padding was added)\n      update(finalState, encode(bitCount), 0, 8);\n      finalState.valid = true;\n    }\n    // make a copy of the hash before returning it.\n    return encode(finalState.state, 16);\n  }\n\n  /**\n   * Returns 32-character hex representation of this hash.\n   *\n   * @return String representation of this object's hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public String getHashString(){\n    return toHex(this.getHash());\n  }\n\n  /**\n   * Gets the MD5 hash of the given byte array.\n   *\n   * @param b byte array for which an MD5 hash is desired.\n   * @return Array of 16 bytes, the hash of all updated bytes.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static byte[] getHash(byte[] b){\n    MD5 md5 = new MD5();\n    md5.update(b);\n    return md5.getHash();\n  }\n\n  /**\n   * Gets the MD5 hash of the given byte array.\n   *\n   * @param b byte array for which an MD5 hash is desired.\n   * @return 32-character hex representation the data's MD5 hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static String getHashString(byte[] b){\n    MD5 md5 = new MD5();\n    md5.update(b);\n    return md5.getHashString();\n  }\n\n  /**\n   * Gets the MD5 hash the data on the given InputStream.\n   *\n   * @param in byte array for which an MD5 hash is desired.\n   * @return Array of 16 bytes, the hash of all updated bytes.\n   * @throws IOException if an I/O error occurs.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static byte[] getHash(InputStream in) throws IOException {\n    MD5 md5 = new MD5();\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = in.read(buffer)) != -1){\n      md5.update(buffer, read);\n    }\n    return md5.getHash();\n  }\n\n  /**\n   * Gets the MD5 hash the data on the given InputStream.\n   *\n   * @param in byte array for which an MD5 hash is desired.\n   * @return 32-character hex representation the data's MD5 hash.\n   * @throws IOException if an I/O error occurs.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static String getHashString(InputStream in) throws IOException {\n    MD5 md5 = new MD5();\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = in.read(buffer)) != -1){\n      md5.update(buffer, read);\n    }\n    return md5.getHashString();\n  }\n\n  /**\n   * Gets the MD5 hash of the given file.\n   *\n   * @param f file for which an MD5 hash is desired.\n   * @return Array of 16 bytes, the hash of all updated bytes.\n   * @throws IOException if an I/O error occurs.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static byte[] getHash(File f) throws IOException {\n    InputStream is = new FileInputStream(f);\n    byte[] hash = getHash(is);\n    is.close();\n    return hash;\n  }\n\n  /**\n   * Gets the MD5 hash of the given file.\n   *\n   * @param f file array for which an MD5 hash is desired.\n   * @return 32-character hex representation the data's MD5 hash.\n   * @throws IOException if an I/O error occurs.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static String getHashString(File f) throws IOException {\n    InputStream is = new FileInputStream(f);\n    String hash = getHashString(is);\n    is.close();\n    return hash;\n  }\n\n  /**\n   * Gets the MD5 hash of the given String.\n   * The string is converted to bytes using the current\n   * platform's default character encoding.\n   *\n   * @param s String for which an MD5 hash is desired.\n   * @return Array of 16 bytes, the hash of all updated bytes.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static byte[] getHash(String s){\n    MD5 md5 = new MD5();\n    md5.update(s);\n    return md5.getHash();\n  }\n\n  /**\n   * Gets the MD5 hash of the given String.\n   * The string is converted to bytes using the current\n   * platform's default character encoding.\n   *\n   * @param s String for which an MD5 hash is desired.\n   * @return 32-character hex representation the data's MD5 hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static String getHashString(String s){\n    MD5 md5 = new MD5();\n    md5.update(s);\n    return md5.getHashString();\n  }\n\n\n  /**\n   * Gets the MD5 hash of the given String.\n   *\n   * @param s String for which an MD5 hash is desired.\n   * @param enc The name of a supported character encoding.\n   * @return Array of 16 bytes, the hash of all updated bytes.\n   * @throws UnsupportedEncodingException If the named encoding is not supported.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static byte[] getHash(String s, String enc) throws UnsupportedEncodingException {\n    MD5 md5 = new MD5();\n    md5.update(s, enc);\n    return md5.getHash();\n  }\n\n  /**\n   * Gets the MD5 hash of the given String.\n   *\n   * @param s String for which an MD5 hash is desired.\n   * @param enc The name of a supported character encoding.\n   * @return 32-character hex representation the data's MD5 hash.\n   * @throws UnsupportedEncodingException If the named encoding is not supported.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public static String getHashString(String s, String enc) throws UnsupportedEncodingException {\n    MD5 md5 = new MD5();\n    md5.update(s, enc);\n    return md5.getHashString();\n  }\n\n\n  /**\n   * Reset the MD5 sum to its initial state.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void reset() {\n    workingState.reset();\n    finalState.valid = false;\n  }\n\n  /**\n   * Returns 32-character hex representation of this hash.\n   *\n   * @return String representation of this object's hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  @Override public String toString(){\n    return getHashString();\n  }\n\n  /**\n   * Update this hash with the given data.\n   * <p>\n   * A state may be passed into this method so that we can add padding\n   * and finalize a md5 hash without limiting our ability to update\n   * more data later.\n   * <p>\n   * If length bytes are not available to be hashed, as many bytes as\n   * possible will be hashed.\n   *\n   * @param state Which state is updated.\n   * @param buffer Array of bytes to be hashed.\n   * @param offset Offset to buffer array.\n   * @param length number of bytes to hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private void update (MD5State state, byte buffer[], int offset, int length) {\n\n    finalState.valid = false;\n\n    // if length goes beyond the end of the buffer, cut it short.\n    if ((length + offset) > buffer.length){\n      length = buffer.length - offset;\n    }\n\n    // compute number of bytes mod 64\n    // this is what we have sitting in a buffer\n    // that have not been hashed yet\n    int index = (int) (state.bitCount >>> 3) & 0x3f;\n\n    // add the length to the count (translate bytes to bits)\n    state.bitCount += length << 3;\n\n    int partlen = 64 - index;\n\n    int i = 0;\n    if (length >= partlen) {\n      System.arraycopy(buffer, offset, state.buffer, index, partlen);\n      transform(state, decode(state.buffer, 64, 0));\n      for (i = partlen; (i + 63) < length; i+= 64){\n        transform(state, decode(buffer, 64, i));\n      }\n      index = 0;\n    }\n\n    // buffer remaining input\n    if (i < length) {\n      for (int start = i; i < length; i++) {\n        state.buffer[index + i - start] = buffer[i + offset];\n      }\n    }\n  }\n\n  /**\n   * Update this hash with the given data.\n   * <p>\n   * If length bytes are not available to be hashed, as many bytes as\n   * possible will be hashed.\n   *\n   * @param buffer Array of bytes to be hashed.\n   * @param offset Offset to buffer array.\n   * @param length number of bytes to hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void update (byte buffer[], int offset, int length) {\n    update(workingState, buffer, offset, length);\n  }\n\n  /**\n   * Update this hash with the given data.\n   * <p>\n   * If length bytes are not available to be hashed, as many bytes as\n   * possible will be hashed.\n   *\n   * @param buffer Array of bytes to be hashed.\n   * @param length number of bytes to hash.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void update (byte buffer[], int length) {\n    update(buffer, 0, length);\n  }\n\n  /**\n   * Update this hash with the given data.\n   *\n   * @param buffer Array of bytes to be hashed.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void update (byte buffer[]) {\n    update(buffer, 0, buffer.length);\n  }\n\n  /**\n   * Updates this hash with a single byte.\n   *\n   * @param b byte to be hashed.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void update (byte b) {\n    byte buffer[] = new byte[1];\n    buffer[0] = b;\n    update(buffer, 1);\n  }\n\n  /**\n   * Update this hash with a String.\n   * The string is converted to bytes using the current\n   * platform's default character encoding.\n   *\n   * @param s String to be hashed.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void update (String s) {\n    update(s.getBytes());\n  }\n\n  /**\n   * Update this hash with a String.\n   *\n   * @param s String to be hashed.\n   * @param enc The name of a supported character encoding.\n   * @throws UnsupportedEncodingException If the named encoding is not supported.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  public void update (String s, String enc) throws UnsupportedEncodingException {\n    update(s.getBytes(enc));\n  }\n\n  /**\n   * The current state from which the hash sum\n   * can be computed or updated.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private MD5State workingState = new MD5State();\n\n  /**\n   * Cached copy of the final MD5 hash sum.  This is created when\n   * the hash is requested and it is invalidated when the hash\n   * is updated.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private MD5State finalState = new MD5State();\n\n  /**\n   * Temporary buffer cached here for performance reasons.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private int[] decodeBuffer = new int[16];\n\n  /**\n   * 64 bytes of padding that can be added if the length\n   * is not divisible by 64.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private static final byte padding[] = {\n    (byte) 0x80, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n  };\n\n  /**\n   * Contains internal state of the MD5 class.\n   * Passes MD5 test suite as defined in RFC1321.\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private class MD5State {\n\n    /**\n     * True if this state is valid.\n     *\n     * @since ostermillerutils 1.00.00\n     */\n    private boolean valid = true;\n\n    /**\n     * Reset to initial state.\n     *\n     * @since ostermillerutils 1.00.00\n     */\n    private void reset(){\n      state[0] = 0x67452301;\n      state[1] = 0xefcdab89;\n      state[2] = 0x98badcfe;\n      state[3] = 0x10325476;\n\n      bitCount = 0;\n    }\n\n    /**\n     * 128-byte state\n     *\n     * @since ostermillerutils 1.00.00\n     */\n    private int state[] = new int[4];\n\n    /**\n     * 64-bit count of the number of bits that have been hashed.\n     *\n     * @since ostermillerutils 1.00.00\n     */\n    private long bitCount;\n\n    /**\n     * 64-byte buffer (512 bits) for storing to-be-hashed characters\n     *\n     * @since ostermillerutils 1.00.00\n     */\n    private byte buffer[] = new byte[64];\n\n    private MD5State() {\n      reset();\n    }\n\n    /**\n     * Set this state to be exactly the same as some other.\n     *\n     * @param from state to copy from.\n     *\n     * @since ostermillerutils 1.00.00\n     */\n    private void copy(MD5State from) {\n      System.arraycopy(from.buffer, 0, this.buffer, 0, this.buffer.length);\n      System.arraycopy(from.state, 0, this.state, 0, this.state.length);\n      this.valid = from.valid;\n      this.bitCount = from.bitCount;\n    }\n  }\n\n\n  /**\n   * Turns array of bytes into string representing each byte as\n   * a two digit unsigned hex number.\n   *\n   * @param hash Array of bytes to convert to hex-string\n   * @return  Generated hex string\n   *\n   * @since ostermillerutils 1.00.00\n   */\n  private static String toHex(byte hash[]){\n    StringBuffer buf = new StringBuffer(hash.length * 2);\n    for (byte element: hash) {\n      int intVal = element & 0xff;\n      if (intVal < 0x10){\n        // append a zero before a one digit hex\n        // number to make it two digits.\n        buf.append(\"0\");\n      }\n      buf.append(Integer.toHexString(intVal));\n    }\n    return buf.toString();\n  }\n\n  private static int FF (int a, int b, int c, int d, int x, int s, int ac) {\n    a += ((b & c) | (~b & d));\n    a += x;\n    a += ac;\n    //return rotateLeft(a, s) + b;\n    a = (a << s) | (a >>> (32 - s));\n    return a + b;\n  }\n\n  private static int GG (int a, int b, int c, int d, int x, int s, int ac) {\n    a += ((b & d) | (c & ~d));\n    a += x;\n    a += ac;\n    //return rotateLeft(a, s) + b;\n    a = (a << s) | (a >>> (32 - s));\n    return a + b;\n  }\n\n  private static int HH (int a, int b, int c, int d, int x, int s, int ac) {\n    a += (b ^ c ^ d);\n    a += x;\n    a += ac;\n    //return rotateLeft(a, s) + b;\n    a = (a << s) | (a >>> (32 - s));\n    return a + b;\n  }\n\n  private static int II (int a, int b, int c, int d, int x, int s, int ac) {\n    a += (c ^ (b | ~d));\n    a += x;\n    a += ac;\n    //return rotateLeft(a, s) + b;\n    a = (a << s) | (a >>> (32 - s));\n    return a + b;\n  }\n\n  private static byte[] encode(long l){\n    byte[] out = new byte[8];\n    out[0] = (byte) (l & 0xff);\n    out[1] = (byte) ((l >>> 8) & 0xff);\n    out[2] = (byte) ((l >>> 16) & 0xff);\n    out[3] = (byte) ((l >>> 24) & 0xff);\n    out[4] = (byte) ((l >>> 32) & 0xff);\n    out[5] = (byte) ((l >>> 40) & 0xff);\n    out[6] = (byte) ((l >>> 48) & 0xff);\n    out[7] = (byte) ((l >>> 56) & 0xff);\n    return out;\n  }\n\n  private static byte[] encode(int input[], int len){\n    byte[] out = new byte[len];\n    int i, j;\n    for (i = j = 0; j  < len; i++, j += 4) {\n      out[j] = (byte) (input[i] & 0xff);\n      out[j + 1] = (byte) ((input[i] >>> 8) & 0xff);\n      out[j + 2] = (byte) ((input[i] >>> 16) & 0xff);\n      out[j + 3] = (byte) ((input[i] >>> 24) & 0xff);\n    }\n    return out;\n  }\n\n  private int[] decode(byte buffer[], int len, int offset){\n    int i, j;\n    for (i = j = 0; j < len; i++, j += 4) {\n      decodeBuffer[i] = (\n        (buffer[j + offset] & 0xff)) |\n        (((buffer[j + 1 + offset] & 0xff)) << 8) |\n        (((buffer[j + 2 + offset] & 0xff)) << 16) |\n        (((buffer[j + 3 + offset] & 0xff)) << 24\n      );\n    }\n    return decodeBuffer;\n  }\n\n  private static void transform(MD5State state, int[] x){\n    int a = state.state[0];\n    int b = state.state[1];\n    int c = state.state[2];\n    int d = state.state[3];\n\n    /* Round 1 */\n    a = FF (a, b, c, d, x[ 0],   7, 0xd76aa478); /* 1 */\n    d = FF (d, a, b, c, x[ 1],  12, 0xe8c7b756); /* 2 */\n    c = FF (c, d, a, b, x[ 2],  17, 0x242070db); /* 3 */\n    b = FF (b, c, d, a, x[ 3],  22, 0xc1bdceee); /* 4 */\n    a = FF (a, b, c, d, x[ 4],   7, 0xf57c0faf); /* 5 */\n    d = FF (d, a, b, c, x[ 5],  12, 0x4787c62a); /* 6 */\n    c = FF (c, d, a, b, x[ 6],  17, 0xa8304613); /* 7 */\n    b = FF (b, c, d, a, x[ 7],  22, 0xfd469501); /* 8 */\n    a = FF (a, b, c, d, x[ 8],   7, 0x698098d8); /* 9 */\n    d = FF (d, a, b, c, x[ 9],  12, 0x8b44f7af); /* 10 */\n    c = FF (c, d, a, b, x[10],  17, 0xffff5bb1); /* 11 */\n    b = FF (b, c, d, a, x[11],  22, 0x895cd7be); /* 12 */\n    a = FF (a, b, c, d, x[12],   7, 0x6b901122); /* 13 */\n    d = FF (d, a, b, c, x[13],  12, 0xfd987193); /* 14 */\n    c = FF (c, d, a, b, x[14],  17, 0xa679438e); /* 15 */\n    b = FF (b, c, d, a, x[15],  22, 0x49b40821); /* 16 */\n\n    /* Round 2 */\n    a = GG (a, b, c, d, x[ 1],   5, 0xf61e2562); /* 17 */\n    d = GG (d, a, b, c, x[ 6],   9, 0xc040b340); /* 18 */\n    c = GG (c, d, a, b, x[11],  14, 0x265e5a51); /* 19 */\n    b = GG (b, c, d, a, x[ 0],  20, 0xe9b6c7aa); /* 20 */\n    a = GG (a, b, c, d, x[ 5],   5, 0xd62f105d); /* 21 */\n    d = GG (d, a, b, c, x[10],   9, 0x02441453); /* 22 */\n    c = GG (c, d, a, b, x[15],  14, 0xd8a1e681); /* 23 */\n    b = GG (b, c, d, a, x[ 4],  20, 0xe7d3fbc8); /* 24 */\n    a = GG (a, b, c, d, x[ 9],   5, 0x21e1cde6); /* 25 */\n    d = GG (d, a, b, c, x[14],   9, 0xc33707d6); /* 26 */\n    c = GG (c, d, a, b, x[ 3],  14, 0xf4d50d87); /* 27 */\n    b = GG (b, c, d, a, x[ 8],  20, 0x455a14ed); /* 28 */\n    a = GG (a, b, c, d, x[13],   5, 0xa9e3e905); /* 29 */\n    d = GG (d, a, b, c, x[ 2],   9, 0xfcefa3f8); /* 30 */\n    c = GG (c, d, a, b, x[ 7],  14, 0x676f02d9); /* 31 */\n    b = GG (b, c, d, a, x[12],  20, 0x8d2a4c8a); /* 32 */\n\n    /* Round 3 */\n    a = HH (a, b, c, d, x[ 5],   4, 0xfffa3942); /* 33 */\n    d = HH (d, a, b, c, x[ 8],  11, 0x8771f681); /* 34 */\n    c = HH (c, d, a, b, x[11],  16, 0x6d9d6122); /* 35 */\n    b = HH (b, c, d, a, x[14],  23, 0xfde5380c); /* 36 */\n    a = HH (a, b, c, d, x[ 1],   4, 0xa4beea44); /* 37 */\n    d = HH (d, a, b, c, x[ 4],  11, 0x4bdecfa9); /* 38 */\n    c = HH (c, d, a, b, x[ 7],  16, 0xf6bb4b60); /* 39 */\n    b = HH (b, c, d, a, x[10],  23, 0xbebfbc70); /* 40 */\n    a = HH (a, b, c, d, x[13],   4, 0x289b7ec6); /* 41 */\n    d = HH (d, a, b, c, x[ 0],  11, 0xeaa127fa); /* 42 */\n    c = HH (c, d, a, b, x[ 3],  16, 0xd4ef3085); /* 43 */\n    b = HH (b, c, d, a, x[ 6],  23, 0x04881d05); /* 44 */\n    a = HH (a, b, c, d, x[ 9],   4, 0xd9d4d039); /* 45 */\n    d = HH (d, a, b, c, x[12],  11, 0xe6db99e5); /* 46 */\n    c = HH (c, d, a, b, x[15],  16, 0x1fa27cf8); /* 47 */\n    b = HH (b, c, d, a, x[ 2],  23, 0xc4ac5665); /* 48 */\n\n    /* Round 4 */\n    a = II (a, b, c, d, x[ 0],   6, 0xf4292244); /* 49 */\n    d = II (d, a, b, c, x[ 7],  10, 0x432aff97); /* 50 */\n    c = II (c, d, a, b, x[14],  15, 0xab9423a7); /* 51 */\n    b = II (b, c, d, a, x[ 5],  21, 0xfc93a039); /* 52 */\n    a = II (a, b, c, d, x[12],   6, 0x655b59c3); /* 53 */\n    d = II (d, a, b, c, x[ 3],  10, 0x8f0ccc92); /* 54 */\n    c = II (c, d, a, b, x[10],  15, 0xffeff47d); /* 55 */\n    b = II (b, c, d, a, x[ 1],  21, 0x85845dd1); /* 56 */\n    a = II (a, b, c, d, x[ 8],   6, 0x6fa87e4f); /* 57 */\n    d = II (d, a, b, c, x[15],  10, 0xfe2ce6e0); /* 58 */\n    c = II (c, d, a, b, x[ 6],  15, 0xa3014314); /* 59 */\n    b = II (b, c, d, a, x[13],  21, 0x4e0811a1); /* 60 */\n    a = II (a, b, c, d, x[ 4],   6, 0xf7537e82); /* 61 */\n    d = II (d, a, b, c, x[11],  10, 0xbd3af235); /* 62 */\n    c = II (c, d, a, b, x[ 2],  15, 0x2ad7d2bb); /* 63 */\n    b = II (b, c, d, a, x[ 9],  21, 0xeb86d391); /* 64 */\n\n    state.state[0] += a;\n    state.state[1] += b;\n    state.state[2] += c;\n    state.state[3] += d;\n  }\n}\n\n   \n    \n    \n    \n    \n    \n    \n  \n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://en.wikipedia.org/wiki/MD5", "url position": 22, "segments": [{"code": "\nd131dd02c5e6eec4 693d9a0698aff95c 2fcab58712467eab 4004583eb8fb7f89\n55ad340609f4b302 83e488832571415a 085125e8f7cdc99f d91dbdf280373c5b\nd8823e3156348f5b ae6dacd436c919c6 dd53e2b487da03fd 02396306d248cda0\ne99f33420f577ee8 ce54b67080a80d1e c69821bcb6a88393 96f9652b6ff72a70\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "\nd131dd02c5e6eec4 693d9a0698aff95c 2fcab50712467eab 4004583eb8fb7f89\n55ad340609f4b302 83e4888325f1415a 085125e8f7cdc99f d91dbd7280373c5b\nd8823e3156348f5b ae6dacd436c919c6 dd53e23487da03fd 02396306d248cda0\ne99f33420f577ee8 ce54b67080280d1e c69821bcb6a88393 96f965ab6ff72a70\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "\n//Note: All variables are unsigned 32 bit and wrap modulo 2^32 when calculating\nvar int[64] s, K\nvar int i\n\n//s specifies the per-round shift amounts\ns[ 0..15] := { 7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22 }\ns[16..31] := { 5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20 }\ns[32..47] := { 4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23 }\ns[48..63] := { 6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 }\n\n//Use binary integer part of the sines of integers (Radians) as constants:\nfor i from 0 to 63\n    K[i] := floor(232  abs(sin(i + 1)))\nend for\n//(Or just use the following precomputed table):\nK[ 0.. 3] := { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee }\nK[ 4.. 7] := { 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 }\nK[ 8..11] := { 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be }\nK[12..15] := { 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 }\nK[16..19] := { 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa }\nK[20..23] := { 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 }\nK[24..27] := { 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed }\nK[28..31] := { 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a }\nK[32..35] := { 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c }\nK[36..39] := { 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 }\nK[40..43] := { 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 }\nK[44..47] := { 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 }\nK[48..51] := { 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 }\nK[52..55] := { 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 }\nK[56..59] := { 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 }\nK[60..63] := { 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }\n\n//Initialize variables:\nvar int a0 := 0x67452301   //A\nvar int b0 := 0xefcdab89   //B\nvar int c0 := 0x98badcfe   //C\nvar int d0 := 0x10325476   //D\n\n//Pre-processing: adding a single 1 bit\nappend \"1\" bit to message    \n// Notice: the input bytes are considered as bits strings,\n//  where the first bit is the most significant bit of the byte.[48]\n\n//Pre-processing: padding with zeros\nappend \"0\" bit until message length in bits  448 (mod 512)\nappend original length in bits mod 264 to message\n\n//Process the message in successive 512-bit chunks:\nfor each 512-bit chunk of padded message\n    break chunk into sixteen 32-bit words M[j], 0  j  15\n//Initialize hash value for this chunk:\n    var int A := a0\n    var int B := b0\n    var int C := c0\n    var int D := d0\n//Main loop:\n    for i from 0 to 63\n        var int F, g\n        if 0  i  15 then\n            F := (B and C) or ((not B) and D)\n            g := i\n        else if 16  i  31\n            F := (D and B) or ((not D) and C)\n            g := (5i + 1) mod 16\n        else if 32  i  47\n            F := B xor C xor D\n            g := (3i + 5) mod 16\n        else if 48  i  63\n            F := C xor (B or (not D))\n            g := (7i) mod 16\n//Be wary of the below definitions of a,b,c,d\n        F := F + A + K[i] + M[g]\n        A := D\n        D := C\n        C := B\n        B := B + leftrotate(F, s[i])\n    end for\n//Add this chunk's hash to result so far:\n    a0 := a0 + A\n    b0 := b0 + B\n    c0 := c0 + C\n    d0 := d0 + D\nend for\n\nvar char digest[16] := a0 append b0 append c0 append d0 //(Output is in little-endian)\n\n//leftrotate function definition\nleftrotate (x, c)\n    return (x << c) binary or (x >> (32-c));\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "\n( 0  i  15): F := D xor (B and (C xor D))\n(16  i  31): F := C xor (D and (B xor C))\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "\nMD5(\"The quick brown fox jumps over the lazy dog\") =\n9e107d9d372bb6826bd81d3542a419d6\n", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "\nMD5(\"The quick brown fox jumps over the lazy dog.\") = \ne4d909c290d0fb1ca068ffaddf22cbd0\n", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "\nMD5(\"\") = \nd41d8cd98f00b204e9800998ecf8427e\n", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://howtodoinjava.com/core-java/io/how-to-generate-sha-or-md5-file-checksum-hash-in-java/", "url position": 16, "segments": [{"code": "\nprivate static String getFileChecksum(MessageDigest digest, File file) throws IOException\n{\n\t//Get file input stream for reading the file content\n\tFileInputStream fis = new FileInputStream(file);\n\t\n\t//Create byte array to read data in chunks\n\tbyte[] byteArray = new byte[1024];\n\tint bytesCount = 0; \n\t \n\t//Read file data and update in message digest\n\twhile ((bytesCount = fis.read(byteArray)) != -1) {\n\t\tdigest.update(byteArray, 0, bytesCount);\n\t};\n\t\n\t//close the stream; We don't need it now.\n\tfis.close();\n\t\n\t//Get the hash's bytes\n\tbyte[] bytes = digest.digest();\n\t\n\t//This bytes[] has bytes in decimal format;\n\t//Convert it to hexadecimal format\n\tStringBuilder sb = new StringBuilder();\n\tfor(int i=0; i< bytes.length ;i++)\n\t{\n\t\tsb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));\n\t}\n\t\n\t//return complete hash\n   return sb.toString();\n}\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\n//Create checksum for this file\nFile file = new File(\"c:/temp/testOut.txt\");\n\n//Use MD5 algorithm\nMessageDigest md5Digest = MessageDigest.getInstance(\"MD5\");\n\n//Get the checksum\nString checksum = getFileChecksum(md5Digest, file);\n\n//see checksum\nSystem.out.println(checksum);\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\n//Use SHA-1 algorithm\nMessageDigest shaDigest = MessageDigest.getInstance(\"SHA-1\");\n\n//SHA-1 checksum \nString shaChecksum = getFileChecksum(shaDigest, file);\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "[java] public static void main (String[] args) {...} [/java]", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "http://www.javadb.com/string-to-md5-hash-in-java/", "url position": 17, "segments": [{"code": "package com.javadb.example;import org.apache.commons.codec.binary.Hex;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.security.DigestInputStream;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class Example {public byte[] stringToMD5(String value) {byte[] hash = null;try {MessageDigest md5 = MessageDigest.getInstance(\"MD5\");InputStream stream = new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8));DigestInputStream inputStream = new DigestInputStream(stream, md5);while (inputStream.read() != -1);hash = md5.digest();} catch (NoSuchAlgorithmException | IOException e) {e.printStackTrace();System.exit(-1);}return hash;}public static void main(String[] args) {Example example = new Example();byte[] hash = example.stringToMD5(\"some_password\");//convert to hexadecimal formatString hex = new String(Hex.encodeHex(hash));System.out.println(hex);System.out.println(\"Length of hash: \" + hash.length);System.out.println(\"Length of hex string: \" + hex.length());}}", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "51348ab117bad55f0ea40090f07acfa3Length of hash: 16Length of hex string: 32Process finished with exit code 0", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://www.quickprogrammingtips.com/java/how-to-generate-md5-hash-in-java.html", "url position": 14, "segments": [{"code": "import java.security.MessageDigest;\nimport java.util.Scanner;\nimport javax.xml.bind.DatatypeConverter;\n\n/**\n * Demonstrates how to generate MD5 hash using Java\n * @author JJ\n */\npublic class MD5HashGenerator {\n\n    public static void main(String[] args) {\n        Scanner sn = new Scanner(System.in);\n        System.out.print(\"Please enter data for which MD5 is required:\");\n        String data = sn.nextLine();\n        \n        MD5HashGenerator sj = new MD5HashGenerator();\n        String hash = sj.getMD5Hash(data);\n        System.out.println(\"The MD5 (hexadecimal encoded) hash is:\"+hash);\n    }\n\n    /**\n     * Returns a hexadecimal encoded MD5 hash for the input String.\n     * @param data\n     * @return \n     */\n    private String getMD5Hash(String data) {\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            byte[] hash = digest.digest(data.getBytes(\"UTF-8\"));\n            return bytesToHex(hash); // make it printable\n        }catch(Exception ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n    \n    /**\n     * Use javax.xml.bind.DatatypeConverter class in JDK to convert byte array\n     * to a hexadecimal string. Note that this generates hexadecimal in upper case.\n     * @param hash\n     * @return \n     */\n    private String  bytesToHex(byte[] hash) {\n        return DatatypeConverter.printHexBinary(hash);\n    }\n}", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://crackstation.net/hashing-security.htm", "url position": 20, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://www.safecharge.com/checksum-calculator/cs/scd_checksum.html", "url position": 26, "segments": [{"code": "public static string MD5_ComputeHexaHash (string text) {\n\t// Gets the MD5 hash for text\n\tMD5 md5 = new MD5CryptoServiceProvider();\n\tbyte[] data = Encoding.Default.GetBytes(text);\n\tbyte[] hash = md5.ComputeHash(data);\n\t\t\n\t// Transforms as hexa\n\tstring hexaHash = \"\";\n\t\n\tforeach (byte b in hash) {\n\t\thexaHash += String.Format(\"{0:x2}\", b);\n\t}\n\t\n\t// Returns MD5 hexa hash\n\treturn hexaHash;\t", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "import java.security.MessageDigest;\n\t\npublic static String md5sum(byte[] convertme) {\n\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\n\treturn new String(md.digest(convertme));\n}\t\t\t\t\t\t", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "# Functional style\nuse Digest::MD5 qw(md5 md5_hex md5_base64);\n\t\n$digest = md5($data);\n$digest = md5_hex($data);\n$digest = md5_base64($data);\n\n# OO style\nuse Digest::MD5;\n\t\n$ctx = Digest::MD5->new;\n\t\n$ctx->add($data);\n\t\n$digest = $ctx->digest;\n$digest = $ctx->hexdigest;\n$digest = $ctx->b64digest;", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "$digest = md5($data);\n$digest = hash('md5',$data);", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "import hashlib\n\t\nconverted = hashlib.md5(\"My text\").hexdigest()", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "package require md5\nset digest [md5::md5 -hex \"checksum string\"]\n\n# For performing incremental digest\npackage require md5\n\nset tok [md5::MD5Init]\nmd5::MD5Update $tok \"Tcl \"\nmd5::MD5Update $tok \"does \"\nmd5::MD5Update $tok \"MD5\"\nset digest [md5::MD5Final $tok]", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://www.mathworks.com/matlabcentral/answers/45323-how-to-calculate-hash-sum-of-a-string-using-java?requestedDomain=true", "url position": 23, "segments": [{"code": "import java.security.*;\r\nimport java.math.*;\r\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "md = MessageDigest.getInstance('MD5');\r\nhash = md.digest(double('Your string.'));\r\nbi = BigInteger(1, hash);\r\nchar(bi.toString(16))\r\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "ans = \r\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "b99e5935368933bafefed10b99bb0489\r\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "import java.lang.String;\r\n", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "char(String.format('%032x', bi));\r\n", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "char(String.format('%064x', bi));\r\n", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "%STRING2HASH Convert a string to a 64 char hex hash string (256 bit hash)\r\n%\r\n%   hash = string2hash(string)\r\n%\r\n%IN:\r\n%   string - a string!\r\n%\r\n%OUT:\r\n%   hash - a 64 character string, encoding the 256 bit SHA hash of string\r\n%          in hexadecimal. \r\n", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "function hash = string2hash(string)\r\npersistent md\r\nif isempty(md)\r\n    md = java.security.MessageDigest.getInstance('SHA-256');\r\nend\r\nhash = sprintf('%2.2x', typecast(md.digest(uint8(string)), 'uint8')');\r\nend\r\n", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://www.fileformat.info/tool/hash.htm", "url position": 27, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://www.md5hashgenerator.com/", "url position": 24, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://www.youtube.com/watch?v=9eisErB4MO8", "url position": 28, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html", "url position": 31, "segments": [{"code": "public abstract class MessageDigest\nextends MessageDigestSpi", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n\n try {\n     md.update(toChapter1);\n     MessageDigest tc1 = md.clone();\n     byte[] toChapter1Digest = tc1.digest();\n     md.update(toChapter2);\n     ...etc.\n } catch (CloneNotSupportedException cnse) {\n     throw new DigestException(\"couldn't make digest of partial content\");\n }\n ", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "protectedMessageDigest(Stringalgorithm)", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticMessageDigestgetInstance(Stringalgorithm)\n                                 throws NoSuchAlgorithmException", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public staticMessageDigestgetInstance(Stringalgorithm,\n                        Stringprovider)\n                                 throws NoSuchAlgorithmException,\n                                        NoSuchProviderException", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public staticMessageDigestgetInstance(Stringalgorithm,\n                        Providerprovider)\n                                 throws NoSuchAlgorithmException", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public finalProvidergetProvider()", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidupdate(byteinput)", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidupdate(byte[]input,\n          intoffset,\n          intlen)", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidupdate(byte[]input)", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public finalvoidupdate(ByteBufferinput)", "in_page_order": 11, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicbyte[]digest()", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicintdigest(byte[]buf,\n         intoffset,\n         intlen)\n           throws DigestException", "in_page_order": 13, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicbyte[]digest(byte[]input)", "in_page_order": 14, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicStringtoString()", "in_page_order": 15, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticbooleanisEqual(byte[]digesta,\n              byte[]digestb)", "in_page_order": 16, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicvoidreset()", "in_page_order": 17, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public finalStringgetAlgorithm()", "in_page_order": 18, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public finalintgetDigestLength()", "in_page_order": 19, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicObjectclone()\n             throws CloneNotSupportedException", "in_page_order": 20, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://www.infoworld.com/article/3159186/security/oracle-to-java-devs-stop-signing-jar-files-with-md5.html", "url position": 21, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://archive.sap.com/discussions/thread/3375655", "url position": 34, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/DigestUtils.html", "url position": 33, "segments": [{"code": "public abstract class DigestUtils\nextends java.lang.Object", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "publicDigestUtils()", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticbyte[]md5Digest(byte[]bytes)", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticbyte[]md5Digest(java.io.InputStreaminputStream)\n                        throws java.io.IOException", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public staticjava.lang.Stringmd5DigestAsHex(byte[]bytes)", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "public staticjava.lang.Stringmd5DigestAsHex(java.io.InputStreaminputStream)\n                                       throws java.io.IOException", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public staticjava.lang.StringBuilderappendMd5DigestAsHex(byte[]bytes,\n                                                           java.lang.StringBuilderbuilder)", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "public staticjava.lang.StringBuilderappendMd5DigestAsHex(java.io.InputStreaminputStream,\n                                                           java.lang.StringBuilderbuilder)\n                                                    throws java.io.IOException", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "http://www.mytecbits.com/tools/cryptography/md5generator", "url position": 35, "segments": [{"code": "public static string Generate(string strInput)\r\n{\r\n    MD5 md5 = new MD5CryptoServiceProvider();\r\n\r\n    //provide the string in byte format to the ComputeHash method.\r\n    //This method returns the MD5 hash code in byte array\r\n    byte[] arrHash = md5.ComputeHash(Encoding.UTF8.GetBytes(strInput));\r\n\r\n    // use a Stringbuilder to append the bytes from the array to create a hash code string.\r\n    StringBuilder sbHash = new StringBuilder();\r\n\r\n    // Loop through byte array of the hashed code and format each byte as a hexadecimal code.\r\n    for (int i = 0; i < arrHash.Length; i++)\r\n    {\r\n    sbHash.Append(arrHash[i].ToString(\"x2\"));\r\n    }\r\n\r\n    // Return the hexadecimal MD5 hash code string.\r\n    return sbHash.ToString();\r\n}", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "import java.math.BigInteger;\r\nimport java.security.MessageDigest;\r\n \r\npublic class MD5 {\r\n    public static String GenerateHash(String input) {\r\n        MessageDigest objMD = MessageDigest.getInstance(\"MD5\");\r\n        byte[] bytMD = mobjMDd.digest(input.getBytes());\r\n        BigInteger intNumber = new BigInteger(1, bytMD);\r\n        String strHashCode = intNumber.toString(16);\r\n\t\t\r\n        // pad with 0 if the hexa digits are less then 32.\r\n        while (strHashCode.length() < 32) {\r\n            strHashCode = \"0\" + strHashCode;\r\n        }\r\n        return strHashCode;\r\n    }\r\n}", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "<?php\r\n$str = \"www.MyTecBits.com\";\r\necho md5($str);\r\n?>", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "http://php.net/manual/en/function.md5.php", "url position": 39, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://normalexchange.com/v/a19f0712-02af-11e8-bf07-0143fd493713/c/4056434f-952a-11e5-b565-02f6361de079/?clickid=9014600000014182214-201801-36c1e25493&pubid=4612&_i=1&_s=a19e6cc6-02af-11e8-a5ed-0143fd493762&_r=&_n=&_d=to6", "url position": 29, "segments": []},
{"query": "How to generate MD5 hash code", "url": "https://thebadprogrammer.com/2012/04/java-md5-hash.html", "url position": 40, "segments": [{"code": "public class Hasher {\n    /**\n     * Gets the md5 hash of the passed in bytes\n     *\n     * @param bytes The bytes to determine the md5 hash of\n     * @return a String containing the md5 hash string\n     */\n    public String getMd5Hash(byte[] bytes) {\n        Formatter fm = new Formatter();\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(bytes);\n            bytes = digest.digest();\n            for (byte b : bytes) {\n                fm.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Exception: \" + e);\n        }\n        return fm.out().toString();\n    }\n    public static void main(String[] args) {\n        Hasher hasher = new Hasher();\n        String hash = hasher.getMd5Hash(\"what is the md5 hash of this?\".getBytes());\n        System.out.println(\"hash = \" + hash);\n    }\n}", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "hash = 49a9884c3121800a49d64a5389691d1a\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "bad:~:7> md5 -s \"what is the md5 hash of this?\"\nMD5 (\"what is the md5 hash of this?\") = 49a9884c3121800a49d64a5389691d1a\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://javatutorial.net/java-generate-md5-hash-sum", "url position": 32, "segments": [{"code": "<dependency>\r\n\t<groupId>commons-codec</groupId>\r\n\t<artifactId>commons-codec</artifactId>\r\n\t<version>1.2</version>\r\n</dependency>", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "/**\r\n* Returns the MD5 hex sum of given string\r\n* @param str - the string to be hashed\r\n* @return MD5 hex sum\r\n*/\r\npublic static String md5(String str) {\r\n\treturn DigestUtils.md5Hex(str);\r\n}", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "http://www.twmacinta.com/myjava/fast_md5.php", "url position": 37, "segments": [{"code": "\n    MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n    digest.update(...your data here...);\n    byte[] hash = digest.digest();\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "\n\n    String hash = MD5.asHex(MD5.getHash(new File(filename)));\n\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "\n\n    MD5 md5 = new MD5();\n    md5.Update(myString, null);\n    String hash = md5.asHex();\n\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}]},
{"query": "How to generate MD5 hash code", "url": "https://gist.github.com/ikarius/299062/85b6540c99878f50f082aaee236ef15fc78e527c", "url position": 36, "segments": [{"code": "def generateMD5(final file) {", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   MessageDigest digest = MessageDigest.getInstance(\"MD5\")", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   file.withInputStream(){is->", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   byte[] buffer = new byte[8192]", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   int read = 0", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "      while( (read = is.read(buffer)) > 0) {", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "             digest.update(buffer, 0, read);", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": true}, {"code": "         }", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "     }", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   byte[] md5sum = digest.digest()", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   BigInteger bigInt = new BigInteger(1, md5sum)", "in_page_order": 11, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "   bigInt.toString(16).padLeft(32, '0')", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}, {"code": "}", "in_page_order": 13, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": "11", "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://www.programcreek.com/java-api-examples/index.php?api=org.apache.hadoop.io.MD5Hash", "url position": 38, "segments": [{"code": "<pre class=\"prettyprint\">/**\n * Read dataFile and compute its MD5 checksum.\n */\npublic static MD5Hash computeMd5ForFile(File dataFile) throws IOException {\n  InputStream in = new FileInputStream(dataFile);\n  try {\n    MessageDigest digester = MD5Hash.getDigester();\n    DigestInputStream dis = new DigestInputStream(in, digester);\n    IOUtils.copyBytes(dis, new IOUtils.NullOutputStream(), 128*1024);\n    \n    return new MD5Hash(digester.digest());\n  } finally {\n    IOUtils.closeStream(in);\n  }\n}\n </pre>", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Client-side Method to fetch file from a server\n * Copies the response from the URL to a list of local files.\n * \n * @Return a digest of the received file if getChecksum is true\n */\nstatic MD5Hash getFileClient(String fsName, String id, File[] localPath,\n    boolean getChecksum) throws IOException {\n  byte[] buf = new byte[BUFFER_SIZE];\n\n  String str = NameNode.getHttpUriScheme() + \"://\" + fsName + \"/getimage?\" + id;\n  LOG.info(\"Opening connection to \" + str);\n  //\n  // open connection to remote server\n  //\n  URL url = new URL(str);\n\n  URLConnection connection = SecurityUtil.openSecureHttpConnection(url);\n  InputStream stream = connection.getInputStream();\n  MessageDigest digester = null;\n  if (getChecksum) {\n    digester = MD5Hash.getDigester();\n    stream = new DigestInputStream(stream, digester);\n  }\n  FileOutputStream[] output = null;\n\n  try {\n    if (localPath != null) {\n      output = new FileOutputStream[localPath.length];\n      for (int i = 0; i &lt; output.length; i++) {\n        output[i] = new FileOutputStream(localPath[i]);\n      }\n    }\n    int num = 1;\n    while (num &gt; 0) {\n      num = stream.read(buf);\n      if (num &gt; 0 &amp;&amp; localPath != null) {\n        for (int i = 0; i &lt; output.length; i++) {\n          output[i].write(buf, 0, num);\n        }\n      }\n    }\n  } finally {\n    stream.close();\n    if (output != null) {\n      for (int i = 0; i &lt; output.length; i++) {\n        if (output[i] != null) {\n          output[i].close();\n        }\n      }\n    }\n  }\n  return digester == null ? null : new MD5Hash(digester.digest());\n}\n </pre>", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Read dataFile and compute its MD5 checksum.\n */\npublic static MD5Hash computeMd5ForFile(File dataFile) throws IOException {\n  InputStream in = new FileInputStream(dataFile);\n  try {\n    MessageDigest digester = MD5Hash.getDigester();\n    DigestInputStream dis = new DigestInputStream(in, digester);\n    IOUtils.copyBytes(dis, new IOUtils.NullOutputStream(), 128*1024);\n    \n    return new MD5Hash(digester.digest());\n  } finally {\n    IOUtils.closeStream(in);\n  }\n}\n </pre>", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Read dataFile and compute its MD5 checksum.\n */\npublic static MD5Hash computeMd5ForFile(File dataFile) throws IOException {\n  InputStream in = new FileInputStream(dataFile);\n  try {\n    MessageDigest digester = MD5Hash.getDigester();\n    DigestInputStream dis = new DigestInputStream(in, digester);\n    IOUtils.copyBytes(dis, new IOUtils.NullOutputStream(), 128*1024);\n    \n    return new MD5Hash(digester.digest());\n  } finally {\n    IOUtils.closeStream(in);\n  }\n}\n </pre>", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">private MD5Hash calcPartialBlockChecksum(ExtendedBlock block,\n    long requestLength, DataChecksum checksum, DataInputStream checksumIn)\n    throws IOException {\n  final int bytesPerCRC = checksum.getBytesPerChecksum();\n  final int csize = checksum.getChecksumSize();\n  final byte[] buffer = new byte[4*1024];\n  MessageDigest digester = MD5Hash.getDigester();\n\n  long remaining = requestLength / bytesPerCRC * csize;\n  for (int toDigest = 0; remaining &gt; 0; remaining -= toDigest) {\n    toDigest = checksumIn.read(buffer, 0,\n        (int) Math.min(remaining, buffer.length));\n    if (toDigest &lt; 0) {\n      break;\n    }\n    digester.update(buffer, 0, toDigest);\n  }\n  \n  int partialLength = (int) (requestLength % bytesPerCRC);\n  if (partialLength &gt; 0) {\n    byte[] buf = new byte[partialLength];\n    final InputStream blockIn = datanode.data.getBlockInputStream(block,\n        requestLength - partialLength);\n    try {\n      // Get the CRC of the partialLength.\n      IOUtils.readFully(blockIn, buf, 0, partialLength);\n    } finally {\n      IOUtils.closeStream(blockIn);\n    }\n    checksum.update(buf, 0, partialLength);\n    byte[] partialCrc = new byte[csize];\n    checksum.writeValue(partialCrc, 0, true);\n    digester.update(partialCrc);\n  }\n  return new MD5Hash(digester.digest());\n}\n </pre>", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">private MD5Hash calcPartialBlockChecksum(ExtendedBlock block,\n    long requestLength, DataChecksum checksum, DataInputStream checksumIn)\n    throws IOException {\n  final int bytesPerCRC = checksum.getBytesPerChecksum();\n  final int csize = checksum.getChecksumSize();\n  final byte[] buffer = new byte[4*1024];\n  MessageDigest digester = MD5Hash.getDigester();\n\n  long remaining = requestLength / bytesPerCRC * csize;\n  for (int toDigest = 0; remaining &gt; 0; remaining -= toDigest) {\n    toDigest = checksumIn.read(buffer, 0,\n        (int) Math.min(remaining, buffer.length));\n    if (toDigest &lt; 0) {\n      break;\n    }\n    digester.update(buffer, 0, toDigest);\n  }\n  \n  int partialLength = (int) (requestLength % bytesPerCRC);\n  if (partialLength &gt; 0) {\n    byte[] buf = new byte[partialLength];\n    final InputStream blockIn = datanode.data.getBlockInputStream(block,\n        requestLength - partialLength);\n    try {\n      // Get the CRC of the partialLength.\n      IOUtils.readFully(blockIn, buf, 0, partialLength);\n    } finally {\n      IOUtils.closeStream(blockIn);\n    }\n    checksum.update(buf, 0, partialLength);\n    byte[] partialCrc = new byte[csize];\n    checksum.writeValue(partialCrc, 0, true);\n    digester.update(partialCrc);\n  }\n  return new MD5Hash(digester.digest());\n}\n </pre>", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">private MD5Hash writeDataAndAssertContents(\n    TestImageUploadStreamInjectionHandler h, int iteration)\n    throws IOException {\n\n  // check write digest\n  MessageDigest digester = MD5Hash.getDigester();\n\n  // create stream\n  HttpImageUploadStream ius = new HttpImageUploadStream(httpAddrs, JID, FAKE_NSINFO,\n      startTxId + iteration, 1, bufferSize, maxNumChunks);\n\n  DigestOutputStream ds = new DigestOutputStream(ius, digester);\n  DataOutputStream dos = new DataOutputStream(ds);\n\n  // write actual data\n  byte[] written = writeData(dos, 10240);\n\n  // flush\n  dos.flush();\n\n  // get written hash\n  MD5Hash hash = new MD5Hash(digester.digest());\n\n  // close the stream\n  dos.close();\n  assertContents(cluster, written, startTxId + iteration, hash, h);\n\n  // roll image\n  qjm.saveDigestAndRenameCheckpointImage(startTxId + iteration, hash);\n\n  // final assert of the contents\n  // get contents using input stream obtained from qjm\n  InputStream is = qjm.getImageInputStream(startTxId + iteration)\n      .getInputStream();\n  byte[] contents = new byte[written.length];\n  is.read(contents);\n  assertTrue(Arrays.equals(written, contents));\n\n  return hash;\n}\n </pre>", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n\n  DataOutputStream out = null;\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out = new DataOutputStream(\n        NetUtils.getOutputStream(s, datanode.socketWriteTimeout));\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">protected static String getTraceSignature(String input) throws IOException {\n  Path inputPath = new Path(input);\n  FileSystem fs = inputPath.getFileSystem(new Configuration());\n  FileStatus status = fs.getFileStatus(inputPath);\n  Path qPath = fs.makeQualified(status.getPath());\n  String traceID = status.getModificationTime() + qPath.toString()\n                   + status.getOwner() + status.getLen();\n  return MD5Hash.digest(traceID).toString();\n}\n </pre>", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Map the HDFS based distributed cache file path from original cluster to\n * a unique file name on the simulated cluster.\n * &lt;br&gt; Unique  distributed file names on simulated cluster are generated\n * using original cluster's &lt;li&gt;file path, &lt;li&gt;timestamp and &lt;li&gt; the\n * job-submitter for private distributed cache file.\n * &lt;br&gt; This implies that if on original cluster, a single HDFS file\n * considered as two private distributed cache files for two jobs of\n * different users, then the corresponding simulated jobs will have two\n * different files of the same size in public distributed cache, one for each\n * user. Both these simulated jobs will not share these distributed cache\n * files, thus leading to the same load as seen in the original cluster.\n * @param file distributed cache file path\n * @param timeStamp time stamp of dist cachce file\n * @param isPublic true if this distributed cache file is a public\n *                 distributed cache file\n * @param user job submitter on original cluster\n * @return the mapped path on simulated cluster\n */\nprivate String mapDistCacheFilePath(String file, String timeStamp,\n    boolean isPublic, String user) {\n  String id = file + timeStamp;\n  if (!isPublic) {\n    // consider job-submitter for private distributed cache file\n    id = id.concat(user);\n  }\n  return new Path(distCachePath, MD5Hash.digest(id).toString()).toUri()\n             .getPath();\n}\n </pre>", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">protected static String getTraceSignature(String input) throws IOException {\n  Path inputPath = new Path(input);\n  FileSystem fs = inputPath.getFileSystem(new Configuration());\n  FileStatus status = fs.getFileStatus(inputPath);\n  Path qPath = fs.makeQualified(status.getPath());\n  String traceID = status.getModificationTime() + qPath.toString()\n                   + status.getOwner() + status.getLen();\n  return MD5Hash.digest(traceID).toString();\n}\n </pre>", "in_page_order": 11, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Map the HDFS based distributed cache file path from original cluster to\n * a unique file name on the simulated cluster.\n * &lt;br&gt; Unique  distributed file names on simulated cluster are generated\n * using original cluster's &lt;li&gt;file path, &lt;li&gt;timestamp and &lt;li&gt; the\n * job-submitter for private distributed cache file.\n * &lt;br&gt; This implies that if on original cluster, a single HDFS file\n * considered as two private distributed cache files for two jobs of\n * different users, then the corresponding simulated jobs will have two\n * different files of the same size in public distributed cache, one for each\n * user. Both these simulated jobs will not share these distributed cache\n * files, thus leading to the same load as seen in the original cluster.\n * @param file distributed cache file path\n * @param timeStamp time stamp of dist cachce file\n * @param isPublic true if this distributed cache file is a public\n *                 distributed cache file\n * @param user job submitter on original cluster\n * @return the mapped path on simulated cluster\n */\nprivate String mapDistCacheFilePath(String file, String timeStamp,\n    boolean isPublic, String user) {\n  String id = file + timeStamp;\n  if (!isPublic) {\n    // consider job-submitter for private distributed cache file\n    id = id.concat(user);\n  }\n  return new Path(distCachePath, MD5Hash.digest(id).toString()).toUri()\n             .getPath();\n}\n </pre>", "in_page_order": 12, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">protected static String getTraceSignature(String input) throws IOException {\n  Path inputPath = new Path(input);\n  FileSystem fs = inputPath.getFileSystem(new Configuration());\n  FileStatus status = fs.getFileStatus(inputPath);\n  Path qPath = fs.makeQualified(status.getPath());\n  String traceID = status.getModificationTime() + qPath.toString()\n                   + status.getOwner() + status.getLen();\n  return MD5Hash.digest(traceID).toString();\n}\n </pre>", "in_page_order": 13, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Map the HDFS based distributed cache file path from original cluster to\n * a unique file name on the simulated cluster.\n * &lt;br&gt; Unique  distributed file names on simulated cluster are generated\n * using original cluster's &lt;li&gt;file path, &lt;li&gt;timestamp and &lt;li&gt; the\n * job-submitter for private distributed cache file.\n * &lt;br&gt; This implies that if on original cluster, a single HDFS file\n * considered as two private distributed cache files for two jobs of\n * different users, then the corresponding simulated jobs will have two\n * different files of the same size in public distributed cache, one for each\n * user. Both these simulated jobs will not share these distributed cache\n * files, thus leading to the same load as seen in the original cluster.\n * @param file distributed cache file path\n * @param timeStamp time stamp of dist cachce file\n * @param isPublic true if this distributed cache file is a public\n *                 distributed cache file\n * @param user job submitter on original cluster\n * @return the mapped path on simulated cluster\n */\nprivate String mapDistCacheFilePath(String file, String timeStamp,\n    boolean isPublic, String user) {\n  String id = file + timeStamp;\n  if (!isPublic) {\n    // consider job-submitter for private distributed cache file\n    id = id.concat(user);\n  }\n  return new Path(distCachePath, MD5Hash.digest(id).toString()).toUri()\n             .getPath();\n}\n </pre>", "in_page_order": 14, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">protected static String getTraceSignature(String input) throws IOException {\n  Path inputPath = new Path(input);\n  FileSystem fs = inputPath.getFileSystem(new Configuration());\n  FileStatus status = fs.getFileStatus(inputPath);\n  Path qPath = fs.makeQualified(status.getPath());\n  String traceID = status.getModificationTime() + qPath.toString()\n                   + status.getOwner() + status.getLen();\n  return MD5Hash.digest(traceID).toString();\n}\n </pre>", "in_page_order": 15, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Map the HDFS based distributed cache file path from original cluster to\n * a unique file name on the simulated cluster.\n * &lt;br&gt; Unique  distributed file names on simulated cluster are generated\n * using original cluster's &lt;li&gt;file path, &lt;li&gt;timestamp and &lt;li&gt; the\n * job-submitter for private distributed cache file.\n * &lt;br&gt; This implies that if on original cluster, a single HDFS file\n * considered as two private distributed cache files for two jobs of\n * different users, then the corresponding simulated jobs will have two\n * different files of the same size in public distributed cache, one for each\n * user. Both these simulated jobs will not share these distributed cache\n * files, thus leading to the same load as seen in the original cluster.\n * @param file distributed cache file path\n * @param timeStamp time stamp of dist cachce file\n * @param isPublic true if this distributed cache file is a public\n *                 distributed cache file\n * @param user job submitter on original cluster\n * @return the mapped path on simulated cluster\n */\nprivate String mapDistCacheFilePath(String file, String timeStamp,\n    boolean isPublic, String user) {\n  String id = file + timeStamp;\n  if (!isPublic) {\n    // consider job-submitter for private distributed cache file\n    id = id.concat(user);\n  }\n  return new Path(distCachePath, MD5Hash.digest(id).toString()).toUri()\n             .getPath();\n}\n </pre>", "in_page_order": 16, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/** Convert a Json map to a MD5MD5CRC32FileChecksum. */\npublic static MD5MD5CRC32FileChecksum toMD5MD5CRC32FileChecksum(\n    final Map&lt;?, ?&gt; json) throws IOException {\n  if (json == null) {\n    return null;\n  }\n\n  final Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;)json.get(FileChecksum.class.getSimpleName());\n  final String algorithm = (String)m.get(\"algorithm\");\n  final int length = (int)(long)(Long)m.get(\"length\");\n  final byte[] bytes = StringUtils.hexStringToByte((String)m.get(\"bytes\"));\n\n  final DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n  final int bytesPerCRC = in.readInt();\n  final long crcPerBlock = in.readLong();\n  final MD5Hash md5 = MD5Hash.read(in);\n  final MD5MD5CRC32FileChecksum checksum = new MD5MD5CRC32FileChecksum(\n      bytesPerCRC, crcPerBlock, md5);\n\n  //check algorithm name\n  final String alg = \"MD5-of-\" + crcPerBlock + \"MD5-of-\" + bytesPerCRC + \"CRC32\";\n  if (!alg.equals(algorithm)) {\n    throw new IOException(\"Algorithm not matched: algorithm=\" + algorithm\n        + \", crcPerBlock=\" + crcPerBlock\n        + \", bytesPerCRC=\" + bytesPerCRC);\n  }\n  //check length\n  if (length != checksum.getLength()) {\n    throw new IOException(\"Length not matched: length=\" + length\n        + \", checksum.getLength()=\" + checksum.getLength());\n  }\n\n  return checksum;\n}\n </pre>", "in_page_order": 17, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/** Convert a Json map to a MD5MD5CRC32FileChecksum. */\npublic static MD5MD5CRC32FileChecksum toMD5MD5CRC32FileChecksum(\n    final Map&lt;?, ?&gt; json) throws IOException {\n  if (json == null) {\n    return null;\n  }\n\n  final Map&lt;?, ?&gt; m = (Map&lt;?, ?&gt;)json.get(FileChecksum.class.getSimpleName());\n  final String algorithm = (String)m.get(\"algorithm\");\n  final int length = (int)(long)(Long)m.get(\"length\");\n  final byte[] bytes = StringUtils.hexStringToByte((String)m.get(\"bytes\"));\n\n  final DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n  final int bytesPerCRC = in.readInt();\n  final long crcPerBlock = in.readLong();\n  final MD5Hash md5 = MD5Hash.read(in);\n  final MD5MD5CRC32FileChecksum checksum = new MD5MD5CRC32FileChecksum(\n      bytesPerCRC, crcPerBlock, md5);\n\n  //check algorithm name\n  final String alg = \"MD5-of-\" + crcPerBlock + \"MD5-of-\" + bytesPerCRC + \"CRC32\";\n  if (!alg.equals(algorithm)) {\n    throw new IOException(\"Algorithm not matched: algorithm=\" + algorithm\n        + \", crcPerBlock=\" + crcPerBlock\n        + \", bytesPerCRC=\" + bytesPerCRC);\n  }\n  //check length\n  if (length != checksum.getLength()) {\n    throw new IOException(\"Length not matched: length=\" + length\n        + \", checksum.getLength()=\" + checksum.getLength());\n  }\n\n  return checksum;\n}\n </pre>", "in_page_order": 18, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Load in the filesystem image from file. It's a big list of\n * filenames and blocks.\n */\nprivate void loadFSImage(File curFile, MD5Hash expectedMd5,\n    FSNamesystem target, MetaRecoveryContext recovery) throws IOException {\n  FSImageFormat.Loader loader = new FSImageFormat.Loader(\n      conf, target);\n  loader.load(curFile);\n  target.setBlockPoolId(this.getBlockPoolID());\n\n  // Check that the image digest we loaded matches up with what\n  // we expected\n  MD5Hash readImageMd5 = loader.getLoadedImageMd5();\n  if (expectedMd5 != null &amp;&amp;\n      !expectedMd5.equals(readImageMd5)) {\n    throw new IOException(\"Image file \" + curFile +\n        \" is corrupt with MD5 checksum of \" + readImageMd5 +\n        \" but expecting \" + expectedMd5);\n  }\n\n  long txId = loader.getLoadedImageTxId();\n  LOG.info(\"Loaded image for txid \" + txId + \" from \" + curFile);\n  lastAppliedTxId = txId;\n  storage.setMostRecentCheckpointInfo(txId, curFile.lastModified());\n}\n </pre>", "in_page_order": 19, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Load in the filesystem image from file. It's a big list of\n * filenames and blocks.  Return whether we should\n * \"re-save\" and consolidate the edit-logs\n */\nprivate void loadFSImage(File curFile, MD5Hash expectedMd5) throws IOException {\n  FSImageFormat.Loader loader = new FSImageFormat.Loader(\n      conf, getFSNamesystem());\n  loader.load(curFile);\n  namesystem.setBlockPoolId(this.getBlockPoolID());\n\n  // Check that the image digest we loaded matches up with what\n  // we expected\n  MD5Hash readImageMd5 = loader.getLoadedImageMd5();\n  if (expectedMd5 != null &amp;&amp;\n      !expectedMd5.equals(readImageMd5)) {\n    throw new IOException(\"Image file \" + curFile +\n        \" is corrupt with MD5 checksum of \" + readImageMd5 +\n        \" but expecting \" + expectedMd5);\n  }\n\n  long txId = loader.getLoadedImageTxId();\n  LOG.info(\"Loaded image for txid \" + txId + \" from \" + curFile);\n  lastAppliedTxId = txId;\n  storage.setMostRecentCheckpointInfo(txId, curFile.lastModified());\n}\n </pre>", "in_page_order": 20, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Load in the filesystem image from file. It's a big list of\n * filenames and blocks.\n */\nprivate void loadFSImage(File curFile, MD5Hash expectedMd5,\n    FSNamesystem target, MetaRecoveryContext recovery) throws IOException {\n  // BlockPoolId is required when the FsImageLoader loads the rolling upgrade\n  // information. Make sure the ID is properly set.\n  target.setBlockPoolId(this.getBlockPoolID());\n\n  FSImageFormat.LoaderDelegator loader = FSImageFormat.newLoader(conf, target);\n  loader.load(curFile);\n\n  // Check that the image digest we loaded matches up with what\n  // we expected\n  MD5Hash readImageMd5 = loader.getLoadedImageMd5();\n  if (expectedMd5 != null &amp;&amp;\n      !expectedMd5.equals(readImageMd5)) {\n    throw new IOException(\"Image file \" + curFile +\n        \" is corrupt with MD5 checksum of \" + readImageMd5 +\n        \" but expecting \" + expectedMd5);\n  }\n\n  long txId = loader.getLoadedImageTxId();\n  LOG.info(\"Loaded image for txid \" + txId + \" from \" + curFile);\n  lastAppliedTxId = txId;\n  storage.setMostRecentCheckpointInfo(txId, curFile.lastModified());\n}\n </pre>", "in_page_order": 21, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Moves fsimage.ckpt to fsImage and edits.new to edits\n * Reopens the new edits file.\n * \n * @param newImageSignature the signature of the new image\n */\nvoid rollFSImage(CheckpointSignature newImageSignature) throws IOException {\n  MD5Hash newImageDigest = newImageSignature.getImageDigest();\n  if (!newImageDigest.equals(checkpointImageDigest)) {\n    throw new IOException(\n        \"Checkpoint image is corrupt: expecting an MD5 checksum of\" +\n        newImageDigest + \" but is \" + checkpointImageDigest);\n  }\n  rollFSImage(newImageSignature.getImageDigest());\n}\n </pre>", "in_page_order": 22, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Load in the filesystem image from file. It's a big list of\n * filenames and blocks.\n */\nprivate void loadFSImage(File curFile, MD5Hash expectedMd5,\n    FSNamesystem target, MetaRecoveryContext recovery,\n    boolean requireSameLayoutVersion) throws IOException {\n  // BlockPoolId is required when the FsImageLoader loads the rolling upgrade\n  // information. Make sure the ID is properly set.\n  target.setBlockPoolId(this.getBlockPoolID());\n\n  FSImageFormat.LoaderDelegator loader = FSImageFormat.newLoader(conf, target);\n  loader.load(curFile, requireSameLayoutVersion);\n\n  // Check that the image digest we loaded matches up with what\n  // we expected\n  MD5Hash readImageMd5 = loader.getLoadedImageMd5();\n  if (expectedMd5 != null &amp;&amp;\n      !expectedMd5.equals(readImageMd5)) {\n    throw new IOException(\"Image file \" + curFile +\n        \" is corrupt with MD5 checksum of \" + readImageMd5 +\n        \" but expecting \" + expectedMd5);\n  }\n\n  long txId = loader.getLoadedImageTxId();\n  LOG.info(\"Loaded image for txid \" + txId + \" from \" + curFile);\n  lastAppliedTxId = txId;\n  storage.setMostRecentCheckpointInfo(txId, curFile.lastModified());\n}\n </pre>", "in_page_order": 23, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Load in the filesystem image from file. It's a big list of\n * filenames and blocks.\n */\nprivate void loadFSImage(File curFile, MD5Hash expectedMd5,\n    FSNamesystem target, MetaRecoveryContext recovery,\n    boolean requireSameLayoutVersion) throws IOException {\n  // BlockPoolId is required when the FsImageLoader loads the rolling upgrade\n  // information. Make sure the ID is properly set.\n  target.setBlockPoolId(this.getBlockPoolID());\n\n  FSImageFormat.LoaderDelegator loader = FSImageFormat.newLoader(conf, target);\n  loader.load(curFile, requireSameLayoutVersion);\n\n  // Check that the image digest we loaded matches up with what\n  // we expected\n  MD5Hash readImageMd5 = loader.getLoadedImageMd5();\n  if (expectedMd5 != null &amp;&amp;\n      !expectedMd5.equals(readImageMd5)) {\n    throw new IOException(\"Image file \" + curFile +\n        \" is corrupt with MD5 checksum of \" + readImageMd5 +\n        \" but expecting \" + expectedMd5);\n  }\n\n  long txId = loader.getLoadedImageTxId();\n  LOG.info(\"Loaded image for txid \" + txId + \" from \" + curFile);\n  lastAppliedTxId = txId;\n  storage.setMostRecentCheckpointInfo(txId, curFile.lastModified());\n}\n </pre>", "in_page_order": 24, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Roll the image.\n */\npublic void saveDigestAndRenameCheckpointImage(long txid, MD5Hash digest)\n    throws IOException {\n  MD5Hash storedDigest = checkpointImageDigests.get(txid);\n  if (storedDigest == null || !storedDigest.equals(digest)) {\n    throw new IOException(\"Digest of data written: \" + storedDigest\n        + \" does not match requested digest: \" + digest + \" for txid: \"\n        + txid + \", journal: \" + journalId);\n  }\n  imageManager.saveDigestAndRenameCheckpointImage(txid, digest);\n  checkpointImageDigests.remove(txid);\n}\n </pre>", "in_page_order": 25, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Moves fsimage.ckpt to fsImage and edits.new to edits\n * Reopens the new edits file.\n * \n * @param newImageSignature the signature of the new image\n */\nvoid rollFSImage(CheckpointSignature newImageSignature) throws IOException {\n  MD5Hash newImageDigest = newImageSignature.getImageDigest();\n  if (!newImageDigest.equals(checkpointImageDigest)) {\n    throw new IOException(\n        \"Checkpoint image is corrupt: expecting an MD5 checksum of\" +\n        newImageDigest + \" but is \" + checkpointImageDigest);\n  }\n  rollFSImage(newImageSignature.getImageDigest());\n}\n </pre>", "in_page_order": 26, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Verify that the previously saved md5 for the given file matches\n * expectedMd5.\n *\n * @throws IOException\n */\npublic static void verifySavedMD5(File dataFile, MD5Hash expectedMD5)\n    throws IOException {\n  MD5Hash storedHash = readStoredMd5ForFile(dataFile);\n  // Check the hash itself\n  if (!expectedMD5.equals(storedHash)) {\n    throw new IOException(\n        \"File \" + dataFile + \" did not match stored MD5 checksum \" +\n            \" (stored: \" + storedHash + \", computed: \" + expectedMD5);\n  }\n}\n </pre>", "in_page_order": 27, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Moves fsimage.ckpt to fsImage and edits.new to edits\n * Reopens the new edits file.\n * \n * @param newImageSignature the signature of the new image\n */\nvoid rollFSImage(CheckpointSignature newImageSignature) throws IOException {\n  MD5Hash newImageDigest = newImageSignature.getImageDigest();\n  if (!newImageDigest.equals(checkpointImageDigest)) {\n    throw new IOException(\n        \"Checkpoint image is corrupt: expecting an MD5 checksum of\" +\n        newImageDigest + \" but is \" + checkpointImageDigest);\n  }\n  rollFSImage(newImageSignature.getImageDigest());\n}\n </pre>", "in_page_order": 28, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n\n  DataOutputStream out = null;\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  updateCurrentThreadName(\"getting checksum for block \" + block);\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out = new DataOutputStream(\n        NetUtils.getOutputStream(s, datanode.socketWriteTimeout));\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 29, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n\n  DataOutputStream out = null;\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out = new DataOutputStream(\n        NetUtils.getOutputStream(s, datanode.socketWriteTimeout));\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 30, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n\n  DataOutputStream out = null;\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  updateCurrentThreadName(\"getting checksum for block \" + block);\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out = new DataOutputStream(\n        NetUtils.getOutputStream(s, datanode.socketWriteTimeout));\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 31, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * \n * @param in\n */\nvoid getBlockChecksum(DataInputStream in, VersionAndOpcode versionAndOpcode)\n\t\tthrows IOException {\n\t// header\n\tBlockChecksumHeader blockChecksumHeader = new BlockChecksumHeader(\n\t\t\tversionAndOpcode);\n\tblockChecksumHeader.readFields(in);\n\tfinal int namespaceId = blockChecksumHeader.getNamespaceId();\n\tfinal Block block = new Block(blockChecksumHeader.getBlockId(), 0,\n\t\t\tblockChecksumHeader.getGenStamp());\n\n\tDataOutputStream out = null;\n\tfinal MetaDataInputStream metadataIn = datanode.data\n\t\t\t.getMetaDataInputStream(namespaceId, block);\n\tfinal DataInputStream checksumIn = new DataInputStream(\n\t\t\tnew BufferedInputStream(metadataIn, BUFFER_SIZE));\n\n\tupdateCurrentThreadName(\"getting checksum for block \" + block);\n\ttry {\n\t\t// read metadata file\n\t\tfinal BlockMetadataHeader header = BlockMetadataHeader\n\t\t\t\t.readHeader(checksumIn);\n\t\tfinal DataChecksum checksum = header.getChecksum();\n\t\tfinal int bytesPerCRC = checksum.getBytesPerChecksum();\n\t\tfinal long crcPerBlock = (metadataIn.getLength() - BlockMetadataHeader\n\t\t\t\t.getHeaderSize()) / checksum.getChecksumSize();\n\n\t\t// compute block checksum\n\t\tfinal MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n\t\tif (LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n\t\t\t\t\t+ \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n\t\t}\n\n\t\t// write reply\n\t\tout = new DataOutputStream(NetUtils.getOutputStream(s,\n\t\t\t\tdatanode.socketWriteTimeout));\n\t\tout.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n\t\tout.writeInt(bytesPerCRC);\n\t\tout.writeLong(crcPerBlock);\n\t\tmd5.write(out);\n\t\tout.flush();\n\t} finally {\n\t\tIOUtils.closeStream(out);\n\t\tIOUtils.closeStream(checksumIn);\n\t\tIOUtils.closeStream(metadataIn);\n\t}\n}\n </pre>", "in_page_order": 32, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Save the contents of the FS image to the file.\n */\nvoid saveFSImage(File newFile) throws IOException {\n  FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();\n  FSDirectory fsDir = fsNamesys.dir;\n  long startTime = FSNamesystem.now();\n  //\n  // Write out data\n  //\n  FileOutputStream fstream = new FileOutputStream(newFile);\n  MessageDigest digester = MD5Hash.getDigester();\n  DigestOutputStream fout = new DigestOutputStream(fstream, digester);\n  DataOutputStream out = new DataOutputStream(fout);\n  long numOfBytesWritten = 0;\n  try {\n    out.writeInt(FSConstants.LAYOUT_VERSION);\n    out.writeInt(namespaceID);\n    out.writeLong(fsDir.rootDir.numItemsInTree());\n    out.writeLong(fsNamesys.getGenerationStamp());\n    \n    out.writeBoolean(compressImage);\n    if (compressImage) {\n      String codecClassName = saveCodec.getClass().getCanonicalName();\n      Text.writeString(out, codecClassName);\n      out = new DataOutputStream(saveCodec.createOutputStream(fout));\n      LOG.info(\"Saving image file \" + newFile +\n          \" compressed using codec \" + codecClassName);\n    } else {\n      out = new DataOutputStream(new BufferedOutputStream(fout));\n    }\n    \n    byte[] byteStore = new byte[4*FSConstants.MAX_PATH_LENGTH];\n    ByteBuffer strbuf = ByteBuffer.wrap(byteStore);\n    // save the root\n    saveINode2Image(strbuf, fsDir.rootDir, out);\n    // save the rest of the nodes\n    saveImage(strbuf, 0, fsDir.rootDir, out);\n    fsNamesys.saveFilesUnderConstruction(out);\n    strbuf = null;\n    \n    out.flush();\n    fstream.getChannel().force(true);\n    numOfBytesWritten = fstream.getChannel().position();\n  } finally {\n    out.close();\n  }\n  // set md5 of the saved image\n  imageDigest = new MD5Hash(digester.digest());\n\n  long imageFileLen = newFile.length();\n  if (numOfBytesWritten != imageFileLen) {\n    throw new IOException(\"Something is wrong: write \" + numOfBytesWritten +\n        \" bytes but the image file length is \" + imageFileLen);\n  }\n  LOG.info(\"Image file of size \" + imageFileLen + \" saved in \" \n      + (FSNamesystem.now() - startTime)/1000 + \" seconds.\");\n}\n </pre>", "in_page_order": 33, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n  Token&lt;BlockTokenIdentifier&gt; accessToken = new Token&lt;BlockTokenIdentifier&gt;();\n  accessToken.readFields(in);\n  DataOutputStream out = new DataOutputStream(NetUtils.getOutputStream(s,\n      datanode.socketWriteTimeout));\n  if (datanode.isBlockTokenEnabled) {\n    try {\n      datanode.blockTokenSecretManager.checkAccess(accessToken, null, block, \n          BlockTokenSecretManager.AccessMode.READ);\n    } catch (InvalidToken e) {\n      try {\n        out.writeShort(DataTransferProtocol.OP_STATUS_ERROR_ACCESS_TOKEN);\n        out.flush();\n        throw new IOException(\n            \"Access token verification failed, for client \" + remoteAddress\n                + \" for OP_BLOCK_CHECKSUM for block \" + block);\n      } finally {\n        IOUtils.closeStream(out);\n      }\n    }\n  }\n\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 34, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @return The checksum \n */\npublic static MD5MD5CRC32FileChecksum getFileChecksum(String src,\n    ClientProtocol namenode, SocketFactory socketFactory, int socketTimeout\n    ) throws IOException {\n  //get all block locations\n  List&lt;LocatedBlock&gt; locatedblocks\n      = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE).getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = 0;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      locatedblocks = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE)\n          .getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final Block block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + socketTimeout;\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      Socket sock = null;\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        sock = socketFactory.createSocket();\n        NetUtils.connect(sock,\n            NetUtils.createSocketAddr(datanodes[j].getName()), timeout);\n        sock.setSoTimeout(timeout);\n\n        out = new DataOutputStream(\n            new BufferedOutputStream(NetUtils.getOutputStream(sock), \n                                     DataNode.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(NetUtils.getInputStream(sock));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j].getName() + \": \"\n              + BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        DataTransferProtocol.Sender.opBlockChecksum(out, block.getBlockId(),\n            block.getGenerationStamp(), lb.getAccessToken());\n\n        final DataTransferProtocol.Status reply = DataTransferProtocol.Status.read(in);\n        if (reply != SUCCESS) {\n          if (reply == ERROR_ACCESS_TOKEN\n              &amp;&amp; i &gt; lastRetriedIndex) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                  + \"for file \" + src + \" for block \" + block\n                  + \" from datanode \" + datanodes[j].getName()\n                  + \". Will retry the block once.\");\n            }\n            lastRetriedIndex = i;\n            done = true; // actually it's not done; but we'll retry\n            i--; // repeat at i-th block\n            refetchBlocks = true;\n            break;\n          } else {\n            throw new IOException(\"Bad response \" + reply + \" for block \"\n                + block + \" from datanode \" + datanodes[j].getName());\n          }\n        }\n\n        //read byte-per-checksum\n        final int bpc = in.readInt(); \n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = in.readLong();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = MD5Hash.read(in);\n        md5.write(md5out);\n        \n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j].getName()\n              + \": md5=\" + md5);\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"].getName()=\"\n            + datanodes[j].getName(), ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n        IOUtils.closeSocket(sock);        \n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock, fileMD5);\n}\n </pre>", "in_page_order": 35, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @return The checksum\n */\npublic static MD5MD5CRC32FileChecksum getFileChecksum(\n    int dataTransferVersion, String src,\n    ClientProtocol namenode, ProtocolProxy&lt;ClientProtocol&gt; namenodeProxy,\n    SocketFactory socketFactory, int socketTimeout\n    ) throws IOException {\n  //get all block locations\n  final LocatedBlocks locatedBlocks = callGetBlockLocations(\n      namenode, src, 0, Long.MAX_VALUE, isMetaInfoSuppoted(namenodeProxy));\n  if (locatedBlocks == null) {\n  \tthrow new IOException(\"Null block locations, mostly because non-existent file \" + src);\n  }\n  int namespaceId = 0;\n  if (locatedBlocks instanceof LocatedBlocksWithMetaInfo) {\n    LocatedBlocksWithMetaInfo lBlocks = (LocatedBlocksWithMetaInfo)locatedBlocks;\n    dataTransferVersion = lBlocks.getDataProtocolVersion();\n    namespaceId = lBlocks.getNamespaceID();\n  } else if (dataTransferVersion == -1) {\n    dataTransferVersion = namenode.getDataTransferProtocolVersion();\n  }\n  final List&lt;LocatedBlock&gt; locatedblocks  = locatedBlocks.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = 0;\n  long crcPerBlock = 0;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    LocatedBlock lb = locatedblocks.get(i);\n    final Block block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n\n    //try each datanode location of the block\n    final int timeout = (socketTimeout &gt; 0) ? (socketTimeout +\n      HdfsConstants.READ_TIMEOUT_EXTENSION * datanodes.length) : 0;\n\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      final Socket sock = socketFactory.createSocket();\n      DataOutputStream out = null;\n      DataInputStream in = null;\n\n      try {\n        // connect to a datanode\n        NetUtils.connect(sock,\n            NetUtils.createSocketAddr(datanodes[j].getName()), timeout);\n        sock.setSoTimeout(timeout);\n\n        out = new DataOutputStream(new BufferedOutputStream(\n            NetUtils.getOutputStream(sock), DataNode.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(NetUtils.getInputStream(sock));\n\n        // get block MD5\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j].getName() + \": \"\n              + DataTransferProtocol.OP_BLOCK_CHECKSUM +\n              \", block=\" + block);\n        }\n        \n        /* Write the header */\n        BlockChecksumHeader blockChecksumHeader = new BlockChecksumHeader(\n            dataTransferVersion, namespaceId, block.getBlockId(),\n            block.getGenerationStamp());\n        blockChecksumHeader.writeVersionAndOpCode(out);\n        blockChecksumHeader.write(out);\n        out.flush();\n\n        final short reply = in.readShort();\n        if (reply != DataTransferProtocol.OP_STATUS_SUCCESS) {\n          throw new IOException(\"Bad response \" + reply + \" for block \"\n              + block + \" from datanode \" + datanodes[j].getName());\n        }\n\n        //read byte-per-checksum\n        final int bpc = in.readInt();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n\n        //read crc-per-block\n        final long cpb = in.readLong();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = MD5Hash.read(in);\n        md5.write(md5out);\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j].getName()\n              + \": md5=\" + md5);\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"].getName()=\"\n            + datanodes[j].getName(), ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n        IOUtils.closeSocket(sock);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData());\n  return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock, fileMD5);\n}\n </pre>", "in_page_order": 36, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @return The checksum\n */\npublic static MD5MD5CRC32FileChecksum getFileChecksum(\n    int dataTransferVersion, String src,\n    ClientProtocol namenode, ProtocolProxy&lt;ClientProtocol&gt; namenodeProxy,\n    SocketFactory socketFactory, int socketTimeout\n    ) throws IOException {\n  //get all block locations\n  final LocatedBlocks locatedBlocks = callGetBlockLocations(\n      namenode, src, 0, Long.MAX_VALUE, isMetaInfoSuppoted(namenodeProxy));\n  int namespaceId = 0;\n  if (locatedBlocks instanceof LocatedBlocksWithMetaInfo) {\n    LocatedBlocksWithMetaInfo lBlocks = (LocatedBlocksWithMetaInfo)locatedBlocks;\n    dataTransferVersion = lBlocks.getDataProtocolVersion();\n    namespaceId = lBlocks.getNamespaceID();\n  } else if (dataTransferVersion == -1) {\n    dataTransferVersion = namenode.getDataTransferProtocolVersion();\n  }\n  final List&lt;LocatedBlock&gt; locatedblocks  = locatedBlocks.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = 0;\n  long crcPerBlock = 0;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    LocatedBlock lb = locatedblocks.get(i);\n    final Block block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n\n    //try each datanode location of the block\n    final int timeout = (socketTimeout &gt; 0) ? (socketTimeout +\n      HdfsConstants.READ_TIMEOUT_EXTENSION * datanodes.length) : 0;\n\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      //connect to a datanode\n      final Socket sock = socketFactory.createSocket();\n      NetUtils.connect(sock,\n                       NetUtils.createSocketAddr(datanodes[j].getName()),\n                       timeout);\n      sock.setSoTimeout(timeout);\n\n      DataOutputStream out = new DataOutputStream(\n          new BufferedOutputStream(NetUtils.getOutputStream(sock),\n                                   DataNode.SMALL_BUFFER_SIZE));\n      DataInputStream in = new DataInputStream(NetUtils.getInputStream(sock));\n\n      // get block MD5\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j].getName() + \": \"\n              + DataTransferProtocol.OP_BLOCK_CHECKSUM +\n              \", block=\" + block);\n        }\n        \n        /* Write the header */\n        BlockChecksumHeader blockChecksumHeader = new BlockChecksumHeader(\n            dataTransferVersion, namespaceId, block.getBlockId(),\n            block.getGenerationStamp());\n        blockChecksumHeader.writeVersionAndOpCode(out);\n        blockChecksumHeader.write(out);\n        out.flush();\n\n        final short reply = in.readShort();\n        if (reply != DataTransferProtocol.OP_STATUS_SUCCESS) {\n          throw new IOException(\"Bad response \" + reply + \" for block \"\n              + block + \" from datanode \" + datanodes[j].getName());\n        }\n\n        //read byte-per-checksum\n        final int bpc = in.readInt();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n\n        //read crc-per-block\n        final long cpb = in.readLong();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = MD5Hash.read(in);\n        md5.write(md5out);\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j].getName()\n              + \": md5=\" + md5);\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"].getName()=\"\n            + datanodes[j].getName(), ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n        IOUtils.closeSocket(sock);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData());\n  return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock, fileMD5);\n}\n </pre>", "in_page_order": 37, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @return The checksum \n */\npublic static MD5MD5CRC32FileChecksum getFileChecksum(String src,\n    ClientProtocol namenode, SocketFactory socketFactory, int socketTimeout\n    ) throws IOException {\n  //get all block locations\n  List&lt;LocatedBlock&gt; locatedblocks\n      = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE).getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = 0;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      locatedblocks = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE)\n          .getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final Block block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + socketTimeout;\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      Socket sock = null;\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        sock = socketFactory.createSocket();\n        NetUtils.connect(sock,\n            NetUtils.createSocketAddr(datanodes[j].getName()), timeout);\n        sock.setSoTimeout(timeout);\n\n        out = new DataOutputStream(\n            new BufferedOutputStream(NetUtils.getOutputStream(sock), \n                                     DataNode.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(NetUtils.getInputStream(sock));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j].getName() + \": \"\n              + BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        DataTransferProtocol.Sender.opBlockChecksum(out, block,\n            lb.getBlockToken());\n\n        final DataTransferProtocol.Status reply = DataTransferProtocol.Status.read(in);\n        if (reply != SUCCESS) {\n          if (reply == ERROR_ACCESS_TOKEN\n              &amp;&amp; i &gt; lastRetriedIndex) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                  + \"for file \" + src + \" for block \" + block\n                  + \" from datanode \" + datanodes[j].getName()\n                  + \". Will retry the block once.\");\n            }\n            lastRetriedIndex = i;\n            done = true; // actually it's not done; but we'll retry\n            i--; // repeat at i-th block\n            refetchBlocks = true;\n            break;\n          } else {\n            throw new IOException(\"Bad response \" + reply + \" for block \"\n                + block + \" from datanode \" + datanodes[j].getName());\n          }\n        }\n\n        //read byte-per-checksum\n        final int bpc = in.readInt(); \n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = in.readLong();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = MD5Hash.read(in);\n        md5.write(md5out);\n        \n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j].getName()\n              + \": md5=\" + md5);\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"].getName()=\"\n            + datanodes[j].getName(), ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n        IOUtils.closeSocket(sock);        \n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock, fileMD5);\n}\n </pre>", "in_page_order": 38, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @return The checksum\n */\npublic static MD5MD5CRC32FileChecksum getFileChecksum(\n    int dataTransferVersion, String src,\n    ClientProtocol namenode, ProtocolProxy&lt;ClientProtocol&gt; namenodeProxy,\n    SocketFactory socketFactory, int socketTimeout\n    ) throws IOException {\n  //get all block locations\n  final LocatedBlocks locatedBlocks = callGetBlockLocations(\n      namenode, src, 0, Long.MAX_VALUE, isMetaInfoSuppoted(namenodeProxy));\n  int namespaceId = 0;\n  if (locatedBlocks instanceof LocatedBlocksWithMetaInfo) {\n    LocatedBlocksWithMetaInfo lBlocks = (LocatedBlocksWithMetaInfo)locatedBlocks;\n    dataTransferVersion = lBlocks.getDataProtocolVersion();\n    namespaceId = lBlocks.getNamespaceID();\n  } else if (dataTransferVersion == -1) {\n    dataTransferVersion = namenode.getDataTransferProtocolVersion();\n  }\n  final List&lt;LocatedBlock&gt; locatedblocks  = locatedBlocks.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = 0;\n  long crcPerBlock = 0;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    LocatedBlock lb = locatedblocks.get(i);\n    final Block block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n\n    //try each datanode location of the block\n    final int timeout = (socketTimeout &gt; 0) ? (socketTimeout +\n      HdfsConstants.READ_TIMEOUT_EXTENSION * datanodes.length) : 0;\n\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      //connect to a datanode\n      final Socket sock = socketFactory.createSocket();\n      NetUtils.connect(sock,\n                       NetUtils.createSocketAddr(datanodes[j].getName()),\n                       timeout);\n      sock.setSoTimeout(timeout);\n\n      DataOutputStream out = new DataOutputStream(\n          new BufferedOutputStream(NetUtils.getOutputStream(sock),\n                                   DataNode.SMALL_BUFFER_SIZE));\n      DataInputStream in = new DataInputStream(NetUtils.getInputStream(sock));\n\n      // get block MD5\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j].getName() + \": \"\n              + DataTransferProtocol.OP_BLOCK_CHECKSUM +\n              \", block=\" + block);\n        }\n        out.writeShort(dataTransferVersion);\n        out.write(DataTransferProtocol.OP_BLOCK_CHECKSUM);\n        if (dataTransferVersion &gt;= DataTransferProtocol.FEDERATION_VERSION) {\n          out.writeInt(namespaceId);\n        }\n        out.writeLong(block.getBlockId());\n        out.writeLong(block.getGenerationStamp());\n        out.flush();\n\n        final short reply = in.readShort();\n        if (reply != DataTransferProtocol.OP_STATUS_SUCCESS) {\n          throw new IOException(\"Bad response \" + reply + \" for block \"\n              + block + \" from datanode \" + datanodes[j].getName());\n        }\n\n        //read byte-per-checksum\n        final int bpc = in.readInt();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n\n        //read crc-per-block\n        final long cpb = in.readLong();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = MD5Hash.read(in);\n        md5.write(md5out);\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j].getName()\n              + \": md5=\" + md5);\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"].getName()=\"\n            + datanodes[j].getName(), ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n        IOUtils.closeSocket(sock);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData());\n  return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock, fileMD5);\n}\n </pre>", "in_page_order": 39, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @param clientName the name of the client requesting the checksum.\n * @param namenode the RPC proxy for the namenode\n * @param socketFactory to create sockets to connect to DNs\n * @param socketTimeout timeout to use when connecting and waiting for a response\n * @param encryptionKey the key needed to communicate with DNs in this cluster\n * @param connectToDnViaHostname whether the client should use hostnames instead of IPs\n * @return The checksum \n */\nprivate static MD5MD5CRC32FileChecksum getFileChecksum(String src,\n    String clientName,\n    ClientProtocol namenode, SocketFactory socketFactory, int socketTimeout,\n    DataEncryptionKey encryptionKey, boolean connectToDnViaHostname)\n    throws IOException {\n  //get all block locations\n  LocatedBlocks blockLocations = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n  if (null == blockLocations) {\n    throw new FileNotFoundException(\"File does not exist: \" + src);\n  }\n  List&lt;LocatedBlock&gt; locatedblocks = blockLocations.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = -1;\n  DataChecksum.Type crcType = DataChecksum.Type.DEFAULT;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      blockLocations = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n      if (null == blockLocations) {\n        throw new FileNotFoundException(\"File does not exist: \" + src);\n      }\n      locatedblocks = blockLocations.getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final ExtendedBlock block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + socketTimeout;\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        IOStreamPair pair = connectToDN(socketFactory, connectToDnViaHostname,\n            encryptionKey, datanodes[j], timeout);\n        out = new DataOutputStream(new BufferedOutputStream(pair.out,\n            HdfsConstants.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(pair.in);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j] + \": \"\n              + Op.BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        new Sender(out).blockChecksum(block, lb.getBlockToken());\n\n        final BlockOpResponseProto reply =\n          BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(in));\n\n        if (reply.getStatus() != Status.SUCCESS) {\n          if (reply.getStatus() == Status.ERROR_ACCESS_TOKEN) {\n            throw new InvalidBlockTokenException();\n          } else {\n            throw new IOException(\"Bad response \" + reply + \" for block \"\n                + block + \" from datanode \" + datanodes[j]);\n          }\n        }\n        \n        OpBlockChecksumResponseProto checksumData =\n          reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc = checksumData.getBytesPerCrc();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = checksumData.getCrcPerBlock();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(md5out);\n        \n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct = PBHelper.convert(checksumData\n              .getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n                    \"inferring checksum by reading first byte\");\n          ct = inferChecksumTypeByReading(\n              clientName, socketFactory, socketTimeout, lb, datanodes[j],\n              encryptionKey, connectToDnViaHostname);\n        }\n\n        if (i == 0) { // first block\n          crcType = ct;\n        } else if (crcType != DataChecksum.Type.MIXED\n            &amp;&amp; crcType != ct) {\n          // if crc types are mixed in a file\n          crcType = DataChecksum.Type.MIXED;\n        }\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j] + \": md5=\" + md5);\n        }\n      } catch (InvalidBlockTokenException ibte) {\n        if (i &gt; lastRetriedIndex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                + \"for file \" + src + \" for block \" + block\n                + \" from datanode \" + datanodes[j]\n                + \". Will retry the block once.\");\n          }\n          lastRetriedIndex = i;\n          done = true; // actually it's not done; but we'll retry\n          i--; // repeat at i-th block\n          refetchBlocks = true;\n          break;\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\"+j+\"]=\" + datanodes[j], ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  switch (crcType) {\n    case CRC32:\n      return new MD5MD5CRC32GzipFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    case CRC32C:\n      return new MD5MD5CRC32CastagnoliFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    default:\n      // If there is no block allocated for the file,\n      // return one with the magic entry that matches what previous\n      // hdfs versions return.\n      if (locatedblocks.size() == 0) {\n        return new MD5MD5CRC32GzipFileChecksum(0, 0, fileMD5);\n      }\n\n      // we should never get here since the validity was checked\n      // when getCrcType() was called above.\n      return null;\n  }\n}\n </pre>", "in_page_order": 40, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n  Token&lt;BlockTokenIdentifier&gt; accessToken = new Token&lt;BlockTokenIdentifier&gt;();\n  accessToken.readFields(in);\n  DataOutputStream out = new DataOutputStream(NetUtils.getOutputStream(s,\n      datanode.socketWriteTimeout));\n  if (datanode.isBlockTokenEnabled) {\n    try {\n      datanode.blockTokenSecretManager.checkAccess(accessToken, null, block, \n          BlockTokenSecretManager.AccessMode.READ);\n    } catch (InvalidToken e) {\n      try {\n        out.writeShort(DataTransferProtocol.OP_STATUS_ERROR_ACCESS_TOKEN);\n        out.flush();\n        throw new IOException(\n            \"Access token verification failed, for client \" + remoteAddress\n                + \" for OP_BLOCK_CHECKSUM for \" + block);\n      } finally {\n        IOUtils.closeStream(out);\n      }\n    }\n  }\n\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 41, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @return The checksum \n */\npublic static MD5MD5CRC32FileChecksum getFileChecksum(String src,\n    ClientProtocol namenode, SocketFactory socketFactory, int socketTimeout\n    ) throws IOException {\n  //get all block locations\n  LocatedBlocks blockLocations = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n  if (null == blockLocations) {\n    throw new FileNotFoundException(\"File does not exist: \" + src);\n  }\n  List&lt;LocatedBlock&gt; locatedblocks = blockLocations.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = 0;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      blockLocations = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n      if (null == blockLocations) {\n        throw new FileNotFoundException(\"File does not exist: \" + src);\n      }\n      locatedblocks = blockLocations.getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final ExtendedBlock block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + socketTimeout;\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      Socket sock = null;\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        sock = socketFactory.createSocket();\n        NetUtils.connect(sock,\n            NetUtils.createSocketAddr(datanodes[j].getName()), timeout);\n        sock.setSoTimeout(timeout);\n\n        out = new DataOutputStream(\n            new BufferedOutputStream(NetUtils.getOutputStream(sock), \n                                     HdfsConstants.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(NetUtils.getInputStream(sock));\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j].getName() + \": \"\n              + Op.BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        new Sender(out).blockChecksum(block, lb.getBlockToken());\n\n        final BlockOpResponseProto reply =\n          BlockOpResponseProto.parseFrom(HdfsProtoUtil.vintPrefixed(in));\n\n        if (reply.getStatus() != Status.SUCCESS) {\n          if (reply.getStatus() == Status.ERROR_ACCESS_TOKEN\n              &amp;&amp; i &gt; lastRetriedIndex) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                  + \"for file \" + src + \" for block \" + block\n                  + \" from datanode \" + datanodes[j].getName()\n                  + \". Will retry the block once.\");\n            }\n            lastRetriedIndex = i;\n            done = true; // actually it's not done; but we'll retry\n            i--; // repeat at i-th block\n            refetchBlocks = true;\n            break;\n          } else {\n            throw new IOException(\"Bad response \" + reply + \" for block \"\n                + block + \" from datanode \" + datanodes[j].getName());\n          }\n        }\n        \n        OpBlockChecksumResponseProto checksumData =\n          reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc = checksumData.getBytesPerCrc();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = checksumData.getCrcPerBlock();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(md5out);\n        \n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j].getName()\n              + \": md5=\" + md5);\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"].getName()=\"\n            + datanodes[j].getName(), ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n        IOUtils.closeSocket(sock);        \n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  return new MD5MD5CRC32FileChecksum(bytesPerCRC, crcPerBlock, fileMD5);\n}\n </pre>", "in_page_order": 42, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n * @param src The file path\n * @param clientName the name of the client requesting the checksum.\n * @param namenode the RPC proxy for the namenode\n * @param socketFactory to create sockets to connect to DNs\n * @param socketTimeout timeout to use when connecting and waiting for a response\n * @param encryptionKey the key needed to communicate with DNs in this cluster\n * @param connectToDnViaHostname whether the client should use hostnames instead of IPs\n * @return The checksum \n */\nprivate static MD5MD5CRC32FileChecksum getFileChecksum(String src,\n    String clientName,\n    ClientProtocol namenode, SocketFactory socketFactory, int socketTimeout,\n    DataEncryptionKey encryptionKey, boolean connectToDnViaHostname)\n    throws IOException {\n  //get all block locations\n  LocatedBlocks blockLocations = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n  if (null == blockLocations) {\n    throw new FileNotFoundException(\"File does not exist: \" + src);\n  }\n  List&lt;LocatedBlock&gt; locatedblocks = blockLocations.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = -1;\n  DataChecksum.Type crcType = DataChecksum.Type.DEFAULT;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  //get block checksum for each block\n  for(int i = 0; i &lt; locatedblocks.size(); i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      blockLocations = callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n      if (null == blockLocations) {\n        throw new FileNotFoundException(\"File does not exist: \" + src);\n      }\n      locatedblocks = blockLocations.getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final ExtendedBlock block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + socketTimeout;\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        IOStreamPair pair = connectToDN(socketFactory, connectToDnViaHostname,\n            encryptionKey, datanodes[j], timeout);\n        out = new DataOutputStream(new BufferedOutputStream(pair.out,\n            HdfsConstants.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(pair.in);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j] + \": \"\n              + Op.BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        new Sender(out).blockChecksum(block, lb.getBlockToken());\n\n        final BlockOpResponseProto reply =\n          BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(in));\n\n        if (reply.getStatus() != Status.SUCCESS) {\n          if (reply.getStatus() == Status.ERROR_ACCESS_TOKEN) {\n            throw new InvalidBlockTokenException();\n          } else {\n            throw new IOException(\"Bad response \" + reply + \" for block \"\n                + block + \" from datanode \" + datanodes[j]);\n          }\n        }\n        \n        OpBlockChecksumResponseProto checksumData =\n          reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc = checksumData.getBytesPerCrc();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = checksumData.getCrcPerBlock();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(md5out);\n        \n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct = PBHelper.convert(checksumData\n              .getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n                    \"inferring checksum by reading first byte\");\n          ct = inferChecksumTypeByReading(\n              clientName, socketFactory, socketTimeout, lb, datanodes[j],\n              encryptionKey, connectToDnViaHostname);\n        }\n\n        if (i == 0) { // first block\n          crcType = ct;\n        } else if (crcType != DataChecksum.Type.MIXED\n            &amp;&amp; crcType != ct) {\n          // if crc types are mixed in a file\n          crcType = DataChecksum.Type.MIXED;\n        }\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j] + \": md5=\" + md5);\n        }\n      } catch (InvalidBlockTokenException ibte) {\n        if (i &gt; lastRetriedIndex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                + \"for file \" + src + \" for block \" + block\n                + \" from datanode \" + datanodes[j]\n                + \". Will retry the block once.\");\n          }\n          lastRetriedIndex = i;\n          done = true; // actually it's not done; but we'll retry\n          i--; // repeat at i-th block\n          refetchBlocks = true;\n          break;\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\"+j+\"]=\" + datanodes[j], ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  switch (crcType) {\n    case CRC32:\n      return new MD5MD5CRC32GzipFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    case CRC32C:\n      return new MD5MD5CRC32CastagnoliFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    default:\n      // If there is no block allocated for the file,\n      // return one with the magic entry that matches what previous\n      // hdfs versions return.\n      if (locatedblocks.size() == 0) {\n        return new MD5MD5CRC32GzipFileChecksum(0, 0, fileMD5);\n      }\n\n      // we should never get here since the validity was checked\n      // when getCrcType() was called above.\n      return null;\n  }\n}\n </pre>", "in_page_order": 43, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n */\n@Override\nprotected void opBlockChecksum(DataInputStream in,\n    long blockId, long blockGs, BlockAccessToken accessToken) throws IOException {\n  final Block block = new Block(blockId, 0 , blockGs);\n  DataOutputStream out = new DataOutputStream(NetUtils.getOutputStream(s,\n      datanode.socketWriteTimeout));\n  if (datanode.isAccessTokenEnabled\n      &amp;&amp; !datanode.accessTokenHandler.checkAccess(accessToken, null, block\n          .getBlockId(), AccessTokenHandler.AccessMode.READ)) {\n    try {\n      ERROR_ACCESS_TOKEN.write(out);\n      out.flush();\n      throw new IOException(\n          \"Access token verification failed, for client \" + remoteAddress\n              + \" for OP_BLOCK_CHECKSUM for block \" + block);\n    } finally {\n      IOUtils.closeStream(out);\n    }\n  }\n\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    SUCCESS.write(out);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n\n  //update metrics\n  updateDuration(datanode.myMetrics.blockChecksumOp);\n}\n </pre>", "in_page_order": 44, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of the whole file of a range of the file. Note that the\n * range always starts from the beginning of the file.\n * @param src The file path\n * @param length the length of the range, i.e., the range is [0, length]\n * @return The checksum \n * @see DistributedFileSystem#getFileChecksum(Path)\n */\npublic MD5MD5CRC32FileChecksum getFileChecksum(String src, long length)\n    throws IOException {\n  checkOpen();\n  Preconditions.checkArgument(length &gt;= 0);\n  //get block locations for the file range\n  LocatedBlocks blockLocations = callGetBlockLocations(namenode, src, 0,\n      length);\n  if (null == blockLocations) {\n    throw new FileNotFoundException(\"File does not exist: \" + src);\n  }\n  if (blockLocations.isUnderConstruction()) {\n    throw new IOException(\"Fail to get checksum, since file \" + src\n        + \" is under construction.\");\n  }\n  List&lt;LocatedBlock&gt; locatedblocks = blockLocations.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = -1;\n  DataChecksum.Type crcType = DataChecksum.Type.DEFAULT;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  // get block checksum for each block\n  long remaining = length;\n  if (src.contains(HdfsConstants.SEPARATOR_DOT_SNAPSHOT_DIR_SEPARATOR)) {\n    remaining = Math.min(length, blockLocations.getFileLength());\n  }\n  for(int i = 0; i &lt; locatedblocks.size() &amp;&amp; remaining &gt; 0; i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      blockLocations = callGetBlockLocations(namenode, src, 0, length);\n      if (null == blockLocations) {\n        throw new FileNotFoundException(\"File does not exist: \" + src);\n      }\n      if (blockLocations.isUnderConstruction()) {\n        throw new IOException(\"Fail to get checksum, since file \" + src\n            + \" is under construction.\");\n      }\n      locatedblocks = blockLocations.getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final ExtendedBlock block = lb.getBlock();\n    if (remaining &lt; block.getNumBytes()) {\n      block.setNumBytes(remaining);\n    }\n    remaining -= block.getNumBytes();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000*datanodes.length + dfsClientConf.getSocketTimeout();\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        IOStreamPair pair = connectToDN(datanodes[j], timeout, lb);\n        out = new DataOutputStream(new BufferedOutputStream(pair.out,\n            smallBufferSize));\n        in = new DataInputStream(pair.in);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j] + \": \"\n              + Op.BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        new Sender(out).blockChecksum(block, lb.getBlockToken());\n\n        final BlockOpResponseProto reply =\n          BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(in));\n\n        String logInfo = \"for block \" + block + \" from datanode \" + datanodes[j];\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        OpBlockChecksumResponseProto checksumData =\n          reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc = checksumData.getBytesPerCrc();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = checksumData.getCrcPerBlock();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(md5out);\n        \n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct = PBHelper.convert(checksumData\n              .getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n                    \"inferring checksum by reading first byte\");\n          ct = inferChecksumTypeByReading(lb, datanodes[j]);\n        }\n\n        if (i == 0) { // first block\n          crcType = ct;\n        } else if (crcType != DataChecksum.Type.MIXED\n            &amp;&amp; crcType != ct) {\n          // if crc types are mixed in a file\n          crcType = DataChecksum.Type.MIXED;\n        }\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j] + \": md5=\" + md5);\n        }\n      } catch (InvalidBlockTokenException ibte) {\n        if (i &gt; lastRetriedIndex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                + \"for file \" + src + \" for block \" + block\n                + \" from datanode \" + datanodes[j]\n                + \". Will retry the block once.\");\n          }\n          lastRetriedIndex = i;\n          done = true; // actually it's not done; but we'll retry\n          i--; // repeat at i-th block\n          refetchBlocks = true;\n          break;\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\"+j+\"]=\" + datanodes[j], ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  switch (crcType) {\n    case CRC32:\n      return new MD5MD5CRC32GzipFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    case CRC32C:\n      return new MD5MD5CRC32CastagnoliFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    default:\n      // If there is no block allocated for the file,\n      // return one with the magic entry that matches what previous\n      // hdfs versions return.\n      if (locatedblocks.size() == 0) {\n        return new MD5MD5CRC32GzipFileChecksum(0, 0, fileMD5);\n      }\n\n      // we should never get here since the validity was checked\n      // when getCrcType() was called above.\n      return null;\n  }\n}\n </pre>", "in_page_order": 45, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of the whole file of a range of the file. Note that the\n * range always starts from the beginning of the file.\n * @param src The file path\n * @param length the length of the range, i.e., the range is [0, length]\n * @return The checksum \n * @see DistributedFileSystem#getFileChecksum(Path)\n */\npublic MD5MD5CRC32FileChecksum getFileChecksum(String src, long length)\n    throws IOException {\n  checkOpen();\n  Preconditions.checkArgument(length &gt;= 0);\n  //get block locations for the file range\n  LocatedBlocks blockLocations = callGetBlockLocations(namenode, src, 0,\n      length);\n  if (null == blockLocations) {\n    throw new FileNotFoundException(\"File does not exist: \" + src);\n  }\n  List&lt;LocatedBlock&gt; locatedblocks = blockLocations.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = -1;\n  DataChecksum.Type crcType = DataChecksum.Type.DEFAULT;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  // get block checksum for each block\n  long remaining = length;\n  for(int i = 0; i &lt; locatedblocks.size() &amp;&amp; remaining &gt; 0; i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      blockLocations = callGetBlockLocations(namenode, src, 0, length);\n      if (null == blockLocations) {\n        throw new FileNotFoundException(\"File does not exist: \" + src);\n      }\n      locatedblocks = blockLocations.getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final ExtendedBlock block = lb.getBlock();\n    if (remaining &lt; block.getNumBytes()) {\n      block.setNumBytes(remaining);\n    }\n    remaining -= block.getNumBytes();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + dfsClientConf.socketTimeout;\n    boolean done = false;\n    for(int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        IOStreamPair pair = connectToDN(datanodes[j], timeout, lb);\n        out = new DataOutputStream(new BufferedOutputStream(pair.out,\n            HdfsConstants.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(pair.in);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j] + \": \"\n              + Op.BLOCK_CHECKSUM + \", block=\" + block);\n        }\n        // get block MD5\n        new Sender(out).blockChecksum(block, lb.getBlockToken());\n\n        final BlockOpResponseProto reply =\n          BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(in));\n\n        if (reply.getStatus() != Status.SUCCESS) {\n          if (reply.getStatus() == Status.ERROR_ACCESS_TOKEN) {\n            throw new InvalidBlockTokenException();\n          } else {\n            throw new IOException(\"Bad response \" + reply + \" for block \"\n                + block + \" from datanode \" + datanodes[j]);\n          }\n        }\n        \n        OpBlockChecksumResponseProto checksumData =\n          reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc = checksumData.getBytesPerCrc();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        }\n        else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc\n              + \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = checksumData.getCrcPerBlock();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(md5out);\n        \n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct = PBHelper.convert(checksumData\n              .getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n                    \"inferring checksum by reading first byte\");\n          ct = inferChecksumTypeByReading(lb, datanodes[j]);\n        }\n\n        if (i == 0) { // first block\n          crcType = ct;\n        } else if (crcType != DataChecksum.Type.MIXED\n            &amp;&amp; crcType != ct) {\n          // if crc types are mixed in a file\n          crcType = DataChecksum.Type.MIXED;\n        }\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC\n                + \", crcPerBlock=\" + crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j] + \": md5=\" + md5);\n        }\n      } catch (InvalidBlockTokenException ibte) {\n        if (i &gt; lastRetriedIndex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Got access token error in response to OP_BLOCK_CHECKSUM \"\n                + \"for file \" + src + \" for block \" + block\n                + \" from datanode \" + datanodes[j]\n                + \". Will retry the block once.\");\n          }\n          lastRetriedIndex = i;\n          done = true; // actually it's not done; but we'll retry\n          i--; // repeat at i-th block\n          refetchBlocks = true;\n          break;\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\"+j+\"]=\" + datanodes[j], ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData()); \n  switch (crcType) {\n    case CRC32:\n      return new MD5MD5CRC32GzipFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    case CRC32C:\n      return new MD5MD5CRC32CastagnoliFileChecksum(bytesPerCRC,\n          crcPerBlock, fileMD5);\n    default:\n      // If there is no block allocated for the file,\n      // return one with the magic entry that matches what previous\n      // hdfs versions return.\n      if (locatedblocks.size() == 0) {\n        return new MD5MD5CRC32GzipFileChecksum(0, 0, fileMD5);\n      }\n\n      // we should never get here since the validity was checked\n      // when getCrcType() was called above.\n      return null;\n  }\n}\n </pre>", "in_page_order": 46, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in,\n    VersionAndOpcode versionAndOpcode) throws IOException {\n  // header\n  BlockChecksumHeader blockChecksumHeader =\n      new BlockChecksumHeader(versionAndOpcode);\n  blockChecksumHeader.readFields(in);\n  final int namespaceId = blockChecksumHeader.getNamespaceId();\n  final Block block = new Block(blockChecksumHeader.getBlockId(), 0,\n          blockChecksumHeader.getGenStamp());\n\n  DataOutputStream out = null;\n  InputStream rawStreamIn = null;\n  DataInputStream streamIn = null;\n\n  ReplicaToRead ri = datanode.data.getReplicaToRead(namespaceId, block);\n  if (ri == null) {\n    throw new IOException(\"Unknown block\");\n  }\n\n  updateCurrentThreadName(\"getting checksum for block \" + block);\n  try {\n    int bytesPerCRC;\n    int checksumSize;\n\n    long crcPerBlock;\n    MD5Hash md5;\n    if (!ri.isInlineChecksum()) {\n      rawStreamIn = BlockWithChecksumFileReader.getMetaDataInputStream(\n          datanode.data, namespaceId, block);\n      streamIn = new DataInputStream(new BufferedInputStream(rawStreamIn,\n          BUFFER_SIZE));\n\n      final BlockMetadataHeader header = BlockMetadataHeader\n          .readHeader(streamIn);\n      final DataChecksum checksum = header.getChecksum();\n      bytesPerCRC = checksum.getBytesPerChecksum();\n      checksumSize = checksum.getChecksumSize();\n      crcPerBlock = (((BlockWithChecksumFileReader.MetaDataInputStream) rawStreamIn)\n          .getLength() - BlockMetadataHeader.getHeaderSize()) / checksumSize;\n\n     //compute block checksum\n     md5 = MD5Hash.digest(streamIn);\n    } else {\n      bytesPerCRC = ri.getBytesPerChecksum();\n      checksumSize = DataChecksum.getChecksumSizeByType(ri.getChecksumType());\n      ReplicaToRead replica = datanode.data.getReplicaToRead(namespaceId, block);\n      rawStreamIn = replica.getBlockInputStream(datanode, 0);\n      streamIn = new DataInputStream(new BufferedInputStream(rawStreamIn,\n          BUFFER_SIZE));\n\n      long lengthLeft = ((FileInputStream) rawStreamIn).getChannel().size()\n          - BlockInlineChecksumReader.getHeaderSize();\n      if (lengthLeft == 0) {\n        crcPerBlock = 0;\n        md5 = MD5Hash.digest(new byte[0]);\n      } else {\n        crcPerBlock = (lengthLeft - 1) / (checksumSize + bytesPerCRC) + 1;\n        MessageDigest digester = MD5Hash.getDigester();\n        byte[] buffer = new byte[checksumSize];\n        while (lengthLeft &gt; 0) {\n          if (lengthLeft &gt;= bytesPerCRC + checksumSize) {\n            streamIn.skip(bytesPerCRC);\n            IOUtils.readFully(streamIn, buffer, 0, buffer.length);\n            lengthLeft -= bytesPerCRC\n                + checksumSize;\n          } else if (lengthLeft &gt; checksumSize) {\n            streamIn.skip(lengthLeft - checksumSize);\n            IOUtils.readFully(streamIn, buffer, 0, buffer.length);\n            lengthLeft = 0;\n          } else {\n            out = new DataOutputStream(\n                NetUtils.getOutputStream(s, datanode.socketWriteTimeout));\n            out.writeShort(DataTransferProtocol.OP_STATUS_ERROR);\n            out.flush();\n            // report to name node the corruption.\n            DataBlockScanner.reportBadBlocks(block, namespaceId, datanode);\n            throw new IOException(\"File for namespace \" + namespaceId\n                + \" block \" + block + \" seems to be corrupted\");\n          }\n          digester.update(buffer);\n        }\n        md5 = new MD5Hash(digester.digest(), checksumSize * crcPerBlock);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out = new DataOutputStream(\n        NetUtils.getOutputStream(s, datanode.socketWriteTimeout));\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    if (streamIn != null) {\n      IOUtils.closeStream(streamIn);\n    }\n    if (rawStreamIn != null) {\n      IOUtils.closeStream(rawStreamIn);\n    }\n  }\n}\n </pre>", "in_page_order": 47, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n  Token&lt;BlockTokenIdentifier&gt; accessToken = new Token&lt;BlockTokenIdentifier&gt;();\n  accessToken.readFields(in);\n  DataOutputStream out = new DataOutputStream(NetUtils.getOutputStream(s,\n      datanode.socketWriteTimeout));\n  if (datanode.isBlockTokenEnabled) {\n    try {\n      datanode.blockTokenSecretManager.checkAccess(accessToken, null, block, \n          BlockTokenSecretManager.AccessMode.READ);\n    } catch (InvalidToken e) {\n      try {\n        out.writeShort(DataTransferProtocol.OP_STATUS_ERROR_ACCESS_TOKEN);\n        out.flush();\n        throw new IOException(\n            \"Access token verification failed, for client \" + remoteAddress\n                + \" for OP_BLOCK_CHECKSUM for block \" + block);\n      } finally {\n        IOUtils.closeStream(out);\n      }\n    }\n  }\n\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  updateThreadName(\"getting checksum for block \" + block);\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 48, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get block checksum (MD5 of CRC32).\n * @param in\n */\nvoid getBlockChecksum(DataInputStream in) throws IOException {\n  final Block block = new Block(in.readLong(), 0 , in.readLong());\n  Token&lt;BlockTokenIdentifier&gt; accessToken = new Token&lt;BlockTokenIdentifier&gt;();\n  accessToken.readFields(in);\n  DataOutputStream out = new DataOutputStream(NetUtils.getOutputStream(s,\n      datanode.socketWriteTimeout));\n  if (datanode.isBlockTokenEnabled) {\n    try {\n      datanode.blockTokenSecretManager.checkAccess(accessToken, null, block, \n          BlockTokenSecretManager.AccessMode.READ);\n    } catch (InvalidToken e) {\n      try {\n        out.writeShort(DataTransferProtocol.OP_STATUS_ERROR_ACCESS_TOKEN);\n        out.flush();\n        throw new IOException(\n            \"Access token verification failed, for client \" + remoteAddress\n                + \" for OP_BLOCK_CHECKSUM for block \" + block);\n      } finally {\n        IOUtils.closeStream(out);\n      }\n    }\n  }\n\n  final MetaDataInputStream metadataIn = datanode.data.getMetaDataInputStream(block);\n  final DataInputStream checksumIn = new DataInputStream(new BufferedInputStream(\n      metadataIn, BUFFER_SIZE));\n\n  updateThreadName(\"getting checksum for block \" + block);\n  try {\n    //read metadata file\n    final BlockMetadataHeader header = BlockMetadataHeader.readHeader(checksumIn);\n    final DataChecksum checksum = header.getChecksum(); \n    final int bytesPerCRC = checksum.getBytesPerChecksum();\n    final long crcPerBlock = (metadataIn.getLength()\n        - BlockMetadataHeader.getHeaderSize())/checksum.getChecksumSize();\n    \n    //compute block checksum\n    final MD5Hash md5 = MD5Hash.digest(checksumIn);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"block=\" + block + \", bytesPerCRC=\" + bytesPerCRC\n          + \", crcPerBlock=\" + crcPerBlock + \", md5=\" + md5);\n    }\n\n    //write reply\n    out.writeShort(DataTransferProtocol.OP_STATUS_SUCCESS);\n    out.writeInt(bytesPerCRC);\n    out.writeLong(crcPerBlock);\n    md5.write(out);\n    out.flush();\n  } finally {\n    IOUtils.closeStream(out);\n    IOUtils.closeStream(checksumIn);\n    IOUtils.closeStream(metadataIn);\n  }\n}\n </pre>", "in_page_order": 49, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "<pre class=\"prettyprint\">/**\n * Get the checksum of a file.\n *\n * @param src\n *     The file path\n * @param clientName\n *     the name of the client requesting the checksum.\n * @param namenode\n *     the RPC proxy for the namenode\n * @param socketFactory\n *     to create sockets to connect to DNs\n * @param socketTimeout\n *     timeout to use when connecting and waiting for a response\n * @param encryptionKey\n *     the key needed to communicate with DNs in this cluster\n * @param connectToDnViaHostname\n *     {@see #connectToDnViaHostname()}\n * @return The checksum\n */\nstatic MD5MD5CRC32FileChecksum getFileChecksum(String src, String clientName,\n    ClientProtocol namenode, SocketFactory socketFactory, int socketTimeout,\n    DataEncryptionKey encryptionKey, boolean connectToDnViaHostname)\n    throws IOException {\n  //get all block locations\n  LocatedBlocks blockLocations =\n      callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n  if (null == blockLocations) {\n    throw new FileNotFoundException(\"File does not exist: \" + src);\n  }\n  List&lt;LocatedBlock&gt; locatedblocks = blockLocations.getLocatedBlocks();\n  final DataOutputBuffer md5out = new DataOutputBuffer();\n  int bytesPerCRC = -1;\n  DataChecksum.Type crcType = DataChecksum.Type.DEFAULT;\n  long crcPerBlock = 0;\n  boolean refetchBlocks = false;\n  int lastRetriedIndex = -1;\n\n  //get block checksum for each block\n  for (int i = 0; i &lt; locatedblocks.size(); i++) {\n    if (refetchBlocks) {  // refetch to get fresh tokens\n      blockLocations =\n          callGetBlockLocations(namenode, src, 0, Long.MAX_VALUE);\n      if (null == blockLocations) {\n        throw new FileNotFoundException(\"File does not exist: \" + src);\n      }\n      locatedblocks = blockLocations.getLocatedBlocks();\n      refetchBlocks = false;\n    }\n    LocatedBlock lb = locatedblocks.get(i);\n    final ExtendedBlock block = lb.getBlock();\n    final DatanodeInfo[] datanodes = lb.getLocations();\n    \n    //try each datanode location of the block\n    final int timeout = 3000 * datanodes.length + socketTimeout;\n    boolean done = false;\n    for (int j = 0; !done &amp;&amp; j &lt; datanodes.length; j++) {\n      DataOutputStream out = null;\n      DataInputStream in = null;\n      \n      try {\n        //connect to a datanode\n        IOStreamPair pair =\n            connectToDN(socketFactory, connectToDnViaHostname, encryptionKey,\n                datanodes[j], timeout);\n        out = new DataOutputStream(new BufferedOutputStream(pair.out,\n            HdfsConstants.SMALL_BUFFER_SIZE));\n        in = new DataInputStream(pair.in);\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"write to \" + datanodes[j] + \": \" + Op.BLOCK_CHECKSUM +\n              \", block=\" + block);\n        }\n        // get block MD5\n        new Sender(out).blockChecksum(block, lb.getBlockToken());\n\n        final BlockOpResponseProto reply =\n            BlockOpResponseProto.parseFrom(PBHelper.vintPrefixed(in));\n\n        if (reply.getStatus() != Status.SUCCESS) {\n          if (reply.getStatus() == Status.ERROR_ACCESS_TOKEN) {\n            throw new InvalidBlockTokenException();\n          } else {\n            throw new IOException(\n                \"Bad response \" + reply + \" for block \" + block +\n                    \" from datanode \" + datanodes[j]);\n          }\n        }\n        \n        OpBlockChecksumResponseProto checksumData =\n            reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc = checksumData.getBytesPerCrc();\n        if (i == 0) { //first block\n          bytesPerCRC = bpc;\n        } else if (bpc != bytesPerCRC) {\n          throw new IOException(\"Byte-per-checksum not matched: bpc=\" + bpc +\n              \" but bytesPerCRC=\" + bytesPerCRC);\n        }\n        \n        //read crc-per-block\n        final long cpb = checksumData.getCrcPerBlock();\n        if (locatedblocks.size() &gt; 1 &amp;&amp; i == 0) {\n          crcPerBlock = cpb;\n        }\n\n        //read md5\n        final MD5Hash md5 = new MD5Hash(checksumData.getMd5().toByteArray());\n        md5.write(md5out);\n        \n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct = PBHelper.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n              \"inferring checksum by reading first byte\");\n          ct = inferChecksumTypeByReading(clientName, socketFactory,\n              socketTimeout, lb, datanodes[j], encryptionKey,\n              connectToDnViaHostname);\n        }\n\n        if (i == 0) { // first block\n          crcType = ct;\n        } else if (crcType != DataChecksum.Type.MIXED &amp;&amp; crcType != ct) {\n          // if crc types are mixed in a file\n          crcType = DataChecksum.Type.MIXED;\n        }\n\n        done = true;\n\n        if (LOG.isDebugEnabled()) {\n          if (i == 0) {\n            LOG.debug(\"set bytesPerCRC=\" + bytesPerCRC + \", crcPerBlock=\" +\n                crcPerBlock);\n          }\n          LOG.debug(\"got reply from \" + datanodes[j] + \": md5=\" + md5);\n        }\n      } catch (InvalidBlockTokenException ibte) {\n        if (i &gt; lastRetriedIndex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\n                \"Got access token error in response to OP_BLOCK_CHECKSUM \" +\n                    \"for file \" + src + \" for block \" + block +\n                    \" from datanode \" + datanodes[j] +\n                    \". Will retry the block once.\");\n          }\n          lastRetriedIndex = i;\n          done = true; // actually it's not done; but we'll retry\n          i--; // repeat at i-th block\n          refetchBlocks = true;\n          break;\n        }\n      } catch (IOException ie) {\n        LOG.warn(\"src=\" + src + \", datanodes[\" + j + \"]=\" + datanodes[j], ie);\n      } finally {\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(out);\n      }\n    }\n\n    if (!done) {\n      throw new IOException(\"Fail to get block MD5 for \" + block);\n    }\n  }\n\n  //compute file MD5\n  final MD5Hash fileMD5 = MD5Hash.digest(md5out.getData());\n  switch (crcType) {\n    case CRC32:\n      return new MD5MD5CRC32GzipFileChecksum(bytesPerCRC, crcPerBlock,\n          fileMD5);\n    case CRC32C:\n      return new MD5MD5CRC32CastagnoliFileChecksum(bytesPerCRC, crcPerBlock,\n          fileMD5);\n    default:\n      // If there is no block allocated for the file,\n      // return one with the magic entry that matches what previous\n      // hdfs versions return.\n      if (locatedblocks.size() == 0) {\n        return new MD5MD5CRC32GzipFileChecksum(0, 0, fileMD5);\n      }\n\n      // we should never get here since the validity was checked\n      // when getCrcType() was called above.\n      return null;\n  }\n}\n </pre>", "in_page_order": 50, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}]},
{"query": "How to generate MD5 hash code", "url": "https://www.npmjs.com/package/js-hash-code", "url position": 30, "segments": [{"code": "> npm install js-hash-code\n", "in_page_order": 1, "first_in_page": true, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": false}, {"code": "const hash = require('js-hash-code');\n\nvar obj = [1,2,3];\nvar hashcode = hash(obj);\n// => '-5ba36363'\n", "in_page_order": 2, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "Arguments\n\nobj (*): a javascript object. \nalgo (String|Function): The hash algorithms. default like JAVA hashCode.\nset (Boolean): ignore collection is object or array, has same elements, hash code is same, if true. \n\nReturns\n\n(string): Returns the javascript object hash code.\n", "in_page_order": 3, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": false}, {"code": "// object content with different order, but same value.\nvar obj1 = {'a':1, 'b':2};\nvar obj2 = {'b':2, 'a':1};\n\nhash(obj1)==hash(obj2);\n// => true\n", "in_page_order": 4, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "// array content with different order, but same value.\nvar obj1 = [1, 2];\nvar obj2 = [2, 1];\n\nhash(obj1)==hash(obj2);\n// => false\n", "in_page_order": 5, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "var obj1 = {'0':1, '1':2};\nvar obj2 = {'0':2, '1':1};\n\nhash(obj1)==hash(obj2);\n// => false\n", "in_page_order": 6, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}, {"code": "var obj1 = [1, 2];\nvar obj2 = {'0':1, '1':2};\n\nhash(obj1)==hash(obj2);\n// => false\n\nhash(obj1, true)==hash(obj2, true);\n// => true\n\nhash([])==hash({});\n// => false\n\nhash([], true)==hash({}, true);\n// => true\n\nvar obj1 = [1, [2, 3]];\nvar obj2 = [[3, 2], 1];\n\nhash(obj1, true)==hash(obj2, true);\n// => true\n\nvar obj2 = [{'0':3, '1':2}, 1];\nhash(obj1, true)==hash(obj2, true);\n// => true\n", "in_page_order": 7, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "var obj = [1, 2];\nvar algo = function(str){\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash += (str.charCodeAt(i) % 8);\n    }\n    return hash.toString(16);\n}\n\nhash(obj)\n// => '748c0cf2'\n\nhash(obj, algo)\n// => '199'\n", "in_page_order": 8, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "var obj1 = [1, 2];\n    obj1['a'] = 3;\n// => [ 1, 2, a: 3 ]\n    \nvar obj2 = [2];\n    obj2['a'] = 3;\n    obj2[1] = 1;\n// => [ 2, 1, a: 3 ]\n\nhash(obj1)==hash(obj2);\n// => false\n\nhash(obj1, true)==hash(obj2, true);\n// => true\n", "in_page_order": 9, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": true, "semicolon": true}, {"code": "var str='';\ncrypto.createHash('md5').update(str).digest(\"hex\") == hash(str,'md5')\n// => false\n", "in_page_order": 10, "first_in_page": false, "accepted_answer": false, "answer_votes": 0, "answer_stars": 0, "length": false, "semicolon": true}]}
]